# 4. 기본형 데이터와 참조형 데이터

## 불변 값

변수(variable)와 상수(constant)를 구분하는 성질은 변경 가능성이다. 변경이 가능하다면 변수, 변경할 수 없다면 상수이다. 그리고 상수와 불변 값을 같은 개념으로 오해하기 쉽기에, 명확히 구분할 필요가 있다.

변수와 상수를 구분 짓는 변경 가능성의 대상은 **변수 영역 메모리**이다. 한 번 데이터의 할당이 이뤄진 변수 공간에 다른 데이터를 재할당 할 수 있는지에 대한 여부가 관건이다.

반면에 불변성 여부를 구분할 때의 변경 가능성의 대상은 **데이터 영역의 메모리**이다.

기본형 데이터인 `number, string, boolean, null, undefined, symbol` 은 모두 불변 값이다.

```jsx
let foo = 'abc';
foo = foo + 'def';

let bar1 = 5;
let bar2 = 5;
```

`'abc'` 에 `'def'` 를 추가하면 자바스크립트에서는 `'abcdef'` 라는 새로운 문자열을 만들고 그 주소를 변수 `foo` 의 값에 저장한다. 즉, `‘abc’` 와 `‘abcdef’` 는 별개의 데이터이다.

변수 `bar1` 에 숫자 5를 할당 때, 데이터 영역에서 5를 찾고 없다면 데이터 공간에 새로 5를 만들고 저장한다. 그리고 데이터 영역의 주소를 변수 영역의 bar 라는 이름을 갖고 있는 주소의 값에 할당한다. `bar2` 에 `bar1` 에서 할당한 값과 같은 5를 할당하려고 한다. `bar1` 에서 새로 만들어 놓은 값이 있기 때문에 `bar2` 에서는 주소를 재활용한다. 즉, 없으면 새로 만들고 있으면 재활용한다.

| 변수 영역 | 1001 | 1002 |
| --- | --- | --- |
|  | 이름: bar1, 값: 5001 | 이름: bar2, 값: 5001 |
| 데이터 영역 | 5001 |  |
|  | 5 |  |

**한 번 만들어진 데이터는 변경할 수 없고, 변경을 하기 위해서는 데이터 영역에 새로 만들어 할당하는 방식이기 때문에 기본형은 불변인 것**이다. 그리고 이것이 불변값의 성질이다. 한 번 만들어진 값은 가비지 컬렉팅을 당하지 않는 한 영원히 변하지 않는다.

## 가변 값

참조형의 기본 값은 가변인 경우가 많지만 경우에 설정에 따라 변경 불가능한 경우도 있고, 아예 불변 값으로 활용하는 방안도 있다.

### 참조형 데이터를 변수에 할당하는 과정

```jsx
let obj1 = {
  a: 1,
  b: 'bb',
};
```

| 변수영역 | 주소 | 1001 | 1002 |  |  |
| --- | --- | --- | --- | --- | --- |
|  | 데이터 |  | 이름: obj1, 값: @5001 |  |  |
| 데이터영역 | 주소 | 5001 |  | 5003 | 5004 |
|  | 데이터 | @7103 ~ ? |  | 1 | ‘bbb’ |
| 객체@5001의 변수영역 | 주소 | 7103 | 7104 |  |  |
|  | 데이터 | 이름: a, 값: @5003 | 이름: b, 값: @5004 |  |  |
1. 변수영역의 빈 공간(`@1002`) 를 찾아서 obj1 이라는 이름을 할당한다.
2. 데이터 영역의 주소 `5001` 에 데이터를 저장하려고 보니 여러 개의 프로퍼티로 이뤄진 데이터 그룹이다. 그룹 내부의 프로퍼티들을 저장하기 위해서 별도의 변수 영역을 마련하고, 그 영역의 주소인 `@7103 ~ ?` 를 `@5001` 에 저장한다.
3. `@7103, @7104` 에 각각 a 와 b 라는 프로퍼티의 이름을 지정한다.
4. 데이터 영역에서 숫자 1을 검색한다. 없을 경우 데이터 영역의 `@5003` 에  1 을 할당하고 해당 주소를 `@7103` 주소의 값에 저장한다. 문자열 역시 `@5004` 에 저장하고, 이 주소를 `@7104` 주소의 값에 저장한다.

기본형 데이터와의 차이점은 **객체 변수에 대한 변수영역이 별도로 존재**한다는 것이다. 그림과 같이 객체가 별도로 할애한 영역은 변수 영역이고, **데이터 영역은 기존의 메모리 공간을 그대로 사용**한다.

데이터 영역에 저장된 값은 모두 불변이다. 하지만 **변수에는 다른 값을 얼마든지 대입**할 수 있다. 이 때문에 참조형 데이터는 불변하지 않다고(=가변이다) 하는 것이다.

```jsx
// 참조형 데이터 프로퍼티 재할당
let obj1 = {
  a: 1,
  b: 'bb',
};

obj1.a = 2;
```

`obj1` 객체의 프로퍼티 `a` 에 2 를 할당해보자. 데이터 영역에서 숫자 2 를 검색한다. 없으면 빈 공간인 `@5005` 에 2 를 저장하고 `@5005` 주소를 `@7103` 의 값에 저장한다.

| 변수영역 | 주소 | 1001 | 1002 | … |  |  |
| --- | --- | --- | --- | --- | --- | --- |
|  | 데이터 |  | 이름: obj1, 값: @5001 |  |  |  |
| 데이터영역 | 주소 | 5001 |  | 5003 | 5004 | 5005 |
|  | 데이터 | @7103 ~ ? |  | 1 | ‘bbb’ | 2 |
| 객체@5001의 변수영역 | 주소 | 7103 | 7104 | … |  |  |
|  | 데이터 | 이름: a, 값: @5005 | 이름: b, 값: @5004 |  |  |  |

### 참조형 데이터 프로퍼티에 다시 참조형 데이터를 할당하는 경우

참조형 데이터 프로퍼티에 다시 참조형 데이터를 할당하는 경우를 **중첩 객체(nested object)** 라고 한다.

```jsx
let obj = {
	x: 3,
	arr: [ 3, 4, 5 ]
};
```

| 변수영역 | 주소 | 1001 | 1002 | … |  |  |
| --- | --- | --- | --- | --- | --- | --- |
|  | 데이터 |  | 이름: obj, 값: @5001 |  |  |  |
| 데이터영역 | 주소 | 5001 | 5002 | 5003 | 5004 | 5005 |
|  | 데이터 | @7103 ~ ? | 3 | @8104~? | 4 | 5 |
| 객체@5001의 변수영역 | 주소 | 7103 | 7104 | … |  |  |
|  | 데이터 | 이름: x, 값: @5002 | 이름: arr, 값: @5003 |  |  |  |
| 객체@5003의 변수영역 | 주소 | 8104 | 8105 | 8106 | … |  |
|  | 데이터 | 이름: 0, 값: @5002 | 이름: 1, 값: @5004 | 이름: 2, 값: @5005 |  |  |
1. 컴퓨터는 빈 공간(`@1002`)을 확보한 뒤에 obj 라는 주소 이름을 할당한다.
2. 데이터 저장공간 `@5001` 을 확보하고, 데이터를 저장해야하지만 데이터가 여러 데이터를 모아놓은 그룹(객체)이다. 따라서 각 그룹의 변수(프로퍼티)를 저장하기 위해서 별도의 변수 영역 공간(`@7103 ~ ?`)을 마련한 뒤에 주소를 데이터 저장공간의 주소인 `@5001` 의 데이터에 저장한다.
3. `@7103` 은 이름 `x` 를 할당하고, `@7104` 는 이름을 `arr` 를 할당한다.
4. 데이터 영역에서 3 데이터가 있는지 찾고 없다면 빈 주소 `@5002` 에 저장하고, 이 주소를 `@7103` 의 값에 할당한다.
5. `@7104` 도 객체처럼 동일하게 데이터 그룹(배열)이다. 이 그룹의 내부 프로퍼티들을 저장하기 위해 별도의 변수영역을 마련하고(`@8104 ~ @8106`) 그 영역의 주소들을 `@5003` 에 저장한 뒤에 `@7104` 의 값에 `@5003` 을 할당한다.
6. 배열의 요소가 3 개이므로 변수 공간을 할당하고, 각각 0 ~ 2 까지의 인덱스(이름)를 부여한다.
7. 데이터 영역에서 3 을 검색하고 그 주소를 `@8104` 에 할당한다.
8. 데이터 영역에서 4 을 검색하고 그 주소를 `@8105` 에 할당한다.
9. 데이터 영역에서 5 을 검색하고 그 주소를 `@8106` 에 할당한다.

만약 메모리에서 `obj.arr[1]` 을 검색하고자 한다면 아래와 같은 과정을 거치게 된다.

1. obj 검색1 - `obj` 라는 이름을 가진 식별자의 주소를 찾는다(`@1002`)
2. obj 검색2 - 값이 주소이므로 해당 주소로 이동한다(`@5001`)
3. obj 검색3 - 값이 주소이므로 해당 주소로 이동한다(`@7103 ~ ?`)
4. obj.arr 검색1 - `arr` 라는 이름을 가진 식별자의 주소를 찾는다(`@7104`)
5. obj.arr 검색2 - 값이 주소이므로 해당 주소로 이동한다(`@5003`)
6. obj.arr 검색3 - 값이 주소이므로 해당 주소로 이동한다(`@8104~?`)
7. obj.arr[1] 검색1 - `1` 이라는 이름을 가진 식별자의 주소를 찾는다.
8. obj.arr[1] 검색2 - 값이 주소이기 때문에 그 주소로 이동한다(`@5004`)
9. obj.arr[1] 검색3 - 값이 숫자형 데이터이므로 데이터인 4 를 반환한다.

```jsx
obj.arr = 'str';
```

위와 같이 arr 를 string type 의 값으로 재할당하면 어떻게 될까? `@5006` 이라는 데이터 영역의 주소에 `‘str’` 이라는 문자열 데이터를 할당하고 그 주소를 `@7104` 의 주소의 값에 저장한다.

어떤 데이터에 대해 **자신의 주소를 참조하는 변수의 개수를 참조 카운트**라고 한다. `@5003` 의 참조 카운트는 `@7104` 에서 `@5003` 이 저장되어 있던 시점까지는 1이였다가 `@5006` 이 저장되는 순간에 0 으로 바뀐다. **참조 카운트가 0 인 메모리 주소는 가비지 컬렉터의 수거 대상**이 된다. 가비지 컬렉터는 런타임 환경에 따라 **특정 시점이나 메모리 사용량이 포화상태에 임박할 때마다 자동으로 수거 대상들을 Collecting(수거)** 한다. 수거된 메모리는 할당이 가능한 빈 공간이 된다.

즉, `@5003` 에서 `@5006` 으로 재할당이되어 참조 카운트가 0 이 된다면 가비지 컬렉터의 대상이되고, `@5003` 의 데이터인 `@8104~?` 라는 값도 사라지게 된다. 이 과정에서 연쇄적으로 `@8104~?` 의 각 데이터들의 참조 카운터가 0 이 되고, 그것들도 가비지컬렉터의 대상이 되어 함께 사라지게 된다.

| 변수영역 | 주소 | 1001 | 1002 | … |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- |
|  | 데이터 |  | 이름: obj, 값: @5001 |  |  |  |  |
| 데이터영역 | 주소 | 5001 | 5002 | 5003 | 5004 | 5005 | 5006 |
|  | 데이터 | @7103 ~ ? | 3 | @8104~? | 4 | 5 | ‘str’ |
| 객체@5001의 변수영역 | 주소 | 7103 | 7104 | … |  |  |  |
|  | 데이터 | 이름: x, 값: @5002 | 이름: arr, 값: @5006 |  |  |  |  |
| 객체@5003의 변수영역 | 주소 | 8104 | 8105 | 8106 | … |  |  |
|  | 데이터 | 이름: 0, 값: @5002 | 이름: 1, 값: @5004 | 이름: 2, 값: @5005 |  |  |  |

## 변수 복사 비교

```jsx
let a = 10;
let b = a;

let obj1 = { c: 10, d: 'ddd' };
let obj2 = obj1;
```

| 변수영역 | 주소 | 1001 | 1002 | 1003 | 1004 |
| --- | --- | --- | --- | --- | --- |
|  | 데이터 | 이름: a, 값: @5001 | 이름: b, 값: @5001 | 이름: obj1, 값: @5002 | 이름: obj2, 값: @5002 |
| 데이터영역 | 주소 | 5001 | 5002 | 5003 | … |
|  | 데이터 | 10 | @7103 ~ ? | ‘ddd’ |  |
| 객체@5002의 변수영역 | 주소 | 7103 | 7104 | … |  |
|  | 데이터 | 이름: c, 값: @5001 | 이름: d, 값: @5003 | … |  |

### 1. 기본형

`let a = 1`

변수영역의 `@1001` 이라는 빈 공간을 확보하고 식별자(이름)를 `a` 라고 지정한다. 숫자 10을 데이터 영역에서 찾고 없다면 빈 공간 (`@5001`) 을 확보하고 10 을 저장한 다음에 `@1001` 주소의 값에 `@5001` 을 할당한다. 이후, 기본형 데이터에 대한 변수 선언 및 할당은 종료된다.

`let b = a`

복사는 우선 변수 영역에 `@1002` 라는 빈 공간을 확보하고 식별자(이름)를 b 라고 지정한다. 식별자 a 를 검색해서 값(`@5001`)을 찾는다. 그리고 `@1002` 값에 찾아온 데이터 영역의 주소 값을 대입한다.

### 2. 참조형

`let obj1 = { c: 10, d: 'ddd' };`

변수 영역에서 빈 공간(`@1003`) 을 확보한 뒤 식별자(이름)를 `obj1` 이라고 지정한다. 데이터 영역에서 빈 공간(`@5002`) 를 확보한 뒤 값을 저장해야하지만 값이 데이터의 그룹(객체, 배열 등)이기 때문에 **별도의 변수 영역을 확보(`@7103~?`)해 그 주소를 저장**한다. `@7103` 에는 식별자 c, `@7104` 에는 식별자 d 를 지정한다. c 에 대입할 10은 이미 데이터영역 `@5001` 에 있기 때문에 `@5001` 을 값으로 지정한다. 문자열인 `‘ddd’` 는 데이터 영역에 없기 때문에 빈 공간(`@5003`) 을 확보하고 값을 저장한 뒤, 데이터 영역의 주소 값을 `@7104` 의 값으로 지정한다. 이후, 참조형 데이터인 객체에 대한 변수 선언 및 할당과정은 종료된다.

`let obj2 = obj1;`

변수 영역에서 빈 공간(`@1004`) 을 확보한 뒤 식별자(이름)를 `obj2` 라고 지정한다. 식별자 `obj1` 을 검색해(`@1003`) 그 값인 `@5002` 를 `@1004` 에 값으로 지정한다.

변수를 복사하는 과정은 기본형, 참조형 데이터 **모두 같은 주소를 바라보게 되는 점에서 동일**하다. 복사 과정은 동일하지만 데이터를 할당하는 과정에서 이미 차이가 있기 때문에 변수 복사 이후의 동작에 큰 차이가 발생한다.

### 기본형과 참조형 변수 복사 이후 동작의 차이

```jsx
let a = 10;
let b = a;

let obj1 = { c: 10, d: 'ddd' };
let obj2 = obj1;

b = 15;
obj2.c = 20;
```

| 변수영역 | 주소 | 1001 | 1002 | 1003 | 1004 |  |
| --- | --- | --- | --- | --- | --- | --- |
|  | 데이터 | 이름: a, 값: @5001 | 이름: b, 값: @5001 → @5004 | 이름: obj1, 값: @5002 | 이름: obj2, 값: @5002 |  |
| 데이터영역 | 주소 | 5001 | 5002 | 5003 | 5004 | 5005 |
|  | 데이터 | 10 | @7103 ~ ? | ‘ddd’ | 15 | 20 |
| 객체@5002의 변수영역 | 주소 | 7103 | 7104 | … |  |  |
|  | 데이터 | 이름: c, 값: @5001 → @5005 | 이름: d, 값: @5003 | … |  |  |

변수 b 의 값을 바꿨을 때는 `@1002` 의 값이 달라졌지만, 참조형 데이터를 복사한 obj2(`@1003`) 의 프로퍼티 값을 바꿨지만 값이 달라지지 않는다. 변수 `a` 와 `b` 는 다른 주소를 바라보게 됐지만, `obj1` 과 `obj2` 는 같은 주소의 객체를 바라보고 있다.

```jsx
a !== b // true
obj1 === obj2 // true
```

이러한 결과가 기본형 데이터와 참조형 데이터의 큰 차이다. 대부분은 자바스크립트에서 기본형은 값을 복사하고, 참조형은 주소를 복사한다고 설명하고 있다. 사실은 어떤 데이터든 값을 할당하기 위해서는 주소 값을 복사해야 되기 때문에 자바스크립트의 모든 데이터 타입은 참조형일 수 밖에 없다. 다만 **기본형은 주소 값을 복사하는 과정이 한 번만 이뤄지고, 참조형은 한 단계를 더 거치게 된다는 차이**가 있는 것이다.

만약 내부 프로퍼티를 변경하는 것이 아닌 새로운 객체를 할당하면 어떻게 될까요?

```jsx
let obj1 = { c: 10, d: 'ddd' };
let obj2 = obj1;

obj2 = { c: 20, d: 'ddd' };
```

| 변수영역 | 주소 | 1001 | 1002 |  |  |  |
| --- | --- | --- | --- | --- | --- | --- |
|  | 데이터 | 이름: obj1, 값: @5001 | 이름: obj2, 값: (@5001 → @5004) |  |  |  |
| 데이터영역 | 주소 | 5001 | 5002 | 5003 | 5004 | 5005 |
|  | 데이터 | @7001 ~ ? | 10 | ‘ddd’ | @8001 ~ ? | 20 |
| 객체@5001의 변수영역 | 주소 | 7001 | 7002 |  |  |  |
|  | 데이터 | 이름: c, 값: @5002 | 이름: d, 값: @5003 |  |  |  |
| 객체@5004의 변수영역 | 주소 | 8001 | 8002 |  |  |  |
|  | 데이터 | 이름: c, 값: @5005 | 이름: c, 값: @5003 |  |  |  |

메모리 데이터 영역의 새로운 공간에 객체가 저장되고, 그 주소를 변수 영역의 `obj2` 에 저장할 것이다. 객체에 대한 변경임에도 불구하고 주소 값이 바뀌었다.

즉, 참조형 데이터가 가변 값이라고 설명할 때는 **참조형 데이터 자체를 변경할 경우가 아니라 그 내부의 프로퍼티를 변경할 때만 성립**한다.
