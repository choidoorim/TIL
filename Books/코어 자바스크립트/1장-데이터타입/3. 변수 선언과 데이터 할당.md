# 3. 변수 선언과 데이터 할당

## 변수 선언

```jsx
let a;
```

위의 예제를 말로 풀어본다면 “변할 수 있는 데이터를 만든다. 데이터의 식별자는 a 로 한다”가 된다. 변수란 **변경 가능한 데이터가 담길 수 있는 공간**이다.

메모리 영역에서는 어떤 작업을 수행할까?

| 주소 | … | 1002 | 1003 |
| --- | --- | --- | --- |
| 데이터 |  |  | 이름: a, 값: |

컴퓨터에서는 **메모리에 비어있는 공간 하나를 확보**한다. 1003 이라는 주소 공간의 이름을 `a` 라고 지정한다. 이후에 사용자가 `a` 에 접근하면 컴퓨터는 메모리에서 `a` 라는 이름을 가진 주소를 검색하고, 해당 공간에 담긴 데이터를 반환할 것이다.

## 데이터 할당

```jsx
let a;
a = 'abc';

let b = 'abc';
```

위 a 변수처럼 값을 할당하던, b 처럼 할당하던 자바스크립트 엔진은 결국 같은 동작을 수행한다.

1. 메모리에서 주소 공간을 확보하고, 그 공간에 이름을 설정한다.
2. 이름에 할당된 주소를 찾아 그곳에 데이터를 할당한다.

실제로는 `‘abc'` 라는 값을 직접 저장하지는 않는다. 데이터를 저장하기 위한 **별도의 메모리 공간을 다시 확보해서 문자열 `‘abc’` 를 저장하고 그 주소를 변수 영역에 다시 저장하는 식**으로 이뤄진다. 그리고 데이터의 성질에 따라 **변수영역과 데이터 영역**으로 구분할 수 있다.

| 변수 영역 | 주소 | 1002 | 1003 | 1004 |
| --- | --- | --- | --- | --- |
|  | 데이터 |  | 이름: a, 값: 5003 |  |
| 데이터 영역 | 주소 | 5002 | 5002 | 5003 |
|  | 데이터 |  |  | ‘abc’ |
1. 변수영역에서 빈  `1003` 이라는 주소 공간을 확보한다.
2. 확보한 공간의 식별자를 `a` 라고 지정한다.
3. 데이터 영역에서 빈 주소 공간에 문자열 `‘abc’` 를 지정한다.
4. 변수 영역에서는 `a` 라는 식별자를 검색한다.
5. 데이터 영역의 문자열 주소인 `5003` 을 변수 영역의 `1003` 주소 공간에 **값으로 대입**한다.

그렇다면 왜 변수 영역에 직접 값을 대입하지 않고, 추가로 한 단계를 거칠까? 그 이유는 **데이터 변환을 자유롭게 할 수 있게 하고, 메모리를 더 효율적으로 관리**하기 위해서이다.

자바스크립트에서 number type 은 8byte 의 공간을 할당한다. 하지만 문자열은 특별하게 정해진 규칙이 없다. 한 글자당 영어는 1byte 이고, 한글은 2byte 등으로 각각 필요한 메모리 용량이 가변적이고 글자 수 또한 가변적이기 때문이다. 만약 미리 확보한 공간 내에서만 데이터 변환을 할 수 있다면 변환한 데이터를 **다시 저장하기 위해서는 “확보된 공간을 변환된 데이터 크기에 맞게 늘리는 작업”이 선행**되어야 할 것이다.

변환해야 할 주소 공간이 가장 마지막에 있다면 뒤로 늘리면 되지만, **중간에 있는 데이터라면 복잡해진다. 해당 공간보다 뒤에 저장된 데이터들을 뒤쪽으로 모두 옮기고, 이동시킨 주소를 각 식별자에 연결하는 작업**을 해야 한다. 즉, 컴퓨터가 처리해야 할 연산이 많아지게 된다. 결국 효율적으로 문자열 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 나눠서 저장하는 것이 최적이다.

### 예시

문자열 `'abc'` 에 `‘def’` 를 추가해야 된다면 `‘abc’` 데이터가 할당된 공간에 `‘abcdef’` 를 할당하는게 아니라 `‘abcdef’` 라는 문자열을 새로 만들어서 데이터영역의 별도 공간에 저장하고 그 주소를 변수 영역에 연결한다. 반대로 `'abc'` 에 `‘c’` 를 제거하라고 해도 똑같이 새로 만든다. 기존 문자열에 어떤 변환이 있던 **무조건 새로 만들어서 별도의 공간에 저장**한다.

만약 다른 변수영역의 값 중에 자신의 주소를 저장하는 곳이 하나도 없게된다면 가비지 컬렉터의 수거 대상이 된다.    즉, 변수 영역에서 값이 새로 할당된 후에 버려진 데이터 영역의 주소는 가비지 컬렉터의 수거 대상이 된다는 것이다.

| 변수 영역 | 주소 | 1002 | 1003 | 1004 | … |
| --- | --- | --- | --- | --- | --- |
|  | 데이터 |  | 이름: a, 값: 5004 |  |  |
| 데이터 영역 | 주소 | 5002 | 5002 | 5003 | 5004 |
|  | 데이터 |  |  | ‘abc’ | ‘abcdef’ |

다른 예시로 500 개의 변수를 생성해서 모든 변수에 숫자 5를 할당하는 상황을 생각해보자. 각 변수 공간에 숫자 5를 할당하기 위해서 숫자형의 `8byte` 를 할당하기 위해서는 `500 * 8 = 4000(byte)` 가 필요하게 된다.

하지만 숫자 5 를 별도의 공간에 한 번만 저장하고 해당 주소만 입력한다면 어떨까? 변수 영역의 주소 공간의 크기가 `2byte` 라고 가정해본다면 `500 * 2 + 8 = 1008(byte)` 만 이용하면 된다. 변수 영역과 데이터 영역을 분리시킨다면 이처럼 중복된 데이터에 대한 처리 효율이 좋아진다.
