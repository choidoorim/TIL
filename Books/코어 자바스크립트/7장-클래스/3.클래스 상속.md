# 3. 클래스 상속

## 1. 기본 구현

ES6 이전에는 상속을 다중 프로토타입 체인을 통해 구현했다.

```jsx
let Grade = function () {
  let args = Array.prototype.slice.call(arguments);
  for (let i = 0; i < args.length; i++) {
    this[i] = args[i];
  }
  this.length = args.length;
};

Grade.prototype = [];
let g = new Grade(100, 80);
console.log(g); // Array { [Iterator]  0: 100, 1: 80, length: 2 }
```

결국 자바스크립트에서 클래스 상속을 구현했다는 것은 프로토타입 체이닝을 잘 연결했다는 것이다.

위 코드는 문제가 존재한다. `length` 프로퍼티가 configurable 하고, `Grade.prototype` 에 빈 배열을 매핑했다는 것이다.

```jsx
let g = new Grade(100, 80);
delete g.length;
console.log(g); // Array { [Iterator]  0: 100, 1: 80 }
```

`length` 프로퍼티를 삭제하고 push 를 했더니 push 한 값이 0 번 인덱스에 들어가고, `length` 가 1이 되었다.

```jsx
delete g.length;
g.push(70);
console.log(g); // Array { [Iterator]  0: 70, 1: 80, length: 1 }
```

내장 객체인 배열의 `length` 프로퍼티는 configurable 옵션이 false 이므로 삭제가 불가능하지만, `Grade` 클래스의 인스턴스는 배열 메서드를 상속하지만, 기본적으로 일반 객체의 성질을 지니므로 삭제가 가능해서 문제가 된다.

그렇다면 push 를 했을 때 0 번째 인덱스에 값이 들어가고, length 가 1이 된 이유는 무엇일까? `g.__proto__`, 즉, `Grade.prototype` 이 빈 배열을 가리키고 있기 때문이다. push 명령을 통해 자바스크립트 엔진에서 `g.length` 를 읽으려고 하지만 없기 때문에, `g.__proto__.length` 를 읽어온 것이다. 빈 배열의 length 가 0 이므로 여기에 값을 할당하고 length 값은 1 증가시키는 것이 가능했던 것이다.

`Grade.prototype` 에 요소를 포함하는 배열을 매칭시켰다면 어땠을까?

```jsx
//...
Grade.prototype = [1, 2, 3, 4];
let g = new Grade(100, 80);

delete g.length;
g.push(70);
console.log(g); // Array { [Iterator]  0: 100, 1: 80, 4: 70, length: 5 }
```

prototype 에 length 가 4인 배열을 할당했다. `g.length` 를 찾지만 없기 때문에 `g.__proto__.length` 를 찾고, 값이 4이기 때문에 인덱스 4에 70을 추가하고, `g.length` 에 5를 부여한다. 이처럼 클래스에 있는 값이 인스턴스에 동작에 영향을 미쳐서는 안된다.

직사각형 클래스와 정사각형 클래스가 아래와 같이 존재한다.

```jsx
let Rectangle = function (width, height) {
  this.width = width;
  this.height = height;
};

Rectangle.prototype.getArea = function () {
  return this.width * this.height;
};
let rect = new Rectangle(3, 4);
console.log(rect.getArea()); // 12

let Square = function (width) {
  this.width = width;
};
Square.prototype.getArea = function () {
  return this.width * this.width;
};
let sq = new Square(5);
console.log(sq.getArea()); // 25
```

만약 `Square` 에서 `height` 프로퍼티에 `width` 를 부여한다고하면 `getArea` 도 `Rectangle` 과 동일하게 사용할 수 있다. 그렇다면 Square 를 Rectangle 의 하위 클래스로 삼을 수 있을 것이다.

```jsx
//...
let Square = function (width) {
  Rectangle.call(this, width, width);
};
Square.prototype = new Rectangle();
let sq = new Square(5);
console.log(sq.getArea()); // 25
console.log(sq.__proto__.getArea.call(sq)); // 25
console.log(sq.__proto__.__proto__.getArea.call(sq)); // 25
```

<img width="201" alt="Untitled" src="https://user-images.githubusercontent.com/63203480/226613865-d9cd6994-981a-4f40-80e8-7699be4c3d26.png">

`__proto__` 는 Rectangle 의 인스턴스이고, `width` 와 `height` 가 `undefined` 가 할당되어 있다. `Square.prototype` 에 값이 존재하는 것은 문제가 될 수 있다. 만약 임의로 `Square.prototype.width`(or `height`) 에 값을 부여하고, `sq.width` 의 값을 삭제한다면 프로토타입 체이닝에 의해 엉뚱한 값이 나온다.

```jsx
//...
let Square = function (width) {
  Rectangle.call(this, width, width);
};
Square.prototype = new Rectangle();
Square.prototype.width = 10;
let sq = new Square(5);
delete sq.width;
console.log(sq.getArea()); // 50
```

그리고 constructor 가 아직도 `Rectangle` 를 바라보고 있다.

```jsx
//...
let rect2 = new sq.constructor(2, 3);
console.log(rect2); // Rectangle { width: 2, height: 3 }
```

`sq.constructor` 로 접근하게 되면 `sq.__proto__.__proto__`, 즉 `Rectangle.prototype` 에서 찾게 되고, 이는 `Rectangle` 을 가리키고 있다.
