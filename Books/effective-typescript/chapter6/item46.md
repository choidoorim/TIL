# 아이템46. 타입 선언과 관련된 세 가지 버전 이해하기

의존성 관리는 매우 어렵다. 타입스크립트는 알아서 의존성 문제를 해결해주기 보다는, 의존성 관리를 더 어렵게 만든다. 타입스크립트를 사용할 때는 3 가지의 사항을 추가로 고려해야 한다.

1. 라이브러리 버전
2. 타입 선언(`@types`) 버전
3. 타입스크립트 버전

3 가지 버전중에 하나라도 맞지 않다면 의존성과 상관없어 보이는 곳에서 엉뚱한 오류가 발생할 수 있다. 이렇게 발생된 오류를 해결하기 위해서는 타입스크립트의 복잡한 라이브러리 관리 매커니즘을 이해해야 한다.

타입스크립트에서 일반적으로 의존성을 사용하는 방법은 라이브러리를 `dependencies` 에 설치하고, 타입 정보는 `devDependencies` 로 설치한다.

```
$ npm install react
react@16.8.6

$ npm install --save-dev @types/react
@types/react@16.8.19
```

메이저와 마이너 버전(16.8)이 일치하지만 패치버전은 일치하고 있지 않다.

`@types/react` 의 `@16.8.19` 는 react 의 16.8.x 버전의 API 들을 지원한다는 뜻이다. 따라서 타입선언을 업데이트 할 필요는 없다.

그러나 실제 라이브러리와 타입 정보의 버전이 별도로 관리되는 방식은 4 가지의 문제점이 있다.

### Case1. 라이브러리는 업데이트했지만 타입 선언은 업데이트하지 않은 경우

라이브러리 업데이트와 관련된 **새로운 기능을 사용하려고 할 때마다 타입오류**가 발생하게 된다. 하위호환성이 깨지는 변경이 있었다면, 타입 체커에서 통과되었더라도 런타임에서 오류가 발생할 수 있다.

일반적인 방법으로는 타입 선언도 업데이트하면 된다. 하지만 타입 선언이 업데이트 되지 않았을 수도 있다. 이런 경우에는 보강기법을 활용하여 사용하려는 새 함수와 메서드의 타입 정보를 프로젝트에 추가하는 것이다. 또는 타입 선언의 업데이트가 필요한 부분을 직접 작성하고 공개하여 커뮤니티에 기여하는 방법도 있다.

### Case2. 라이브러리보다 타입 선언의 버전이 최신인 경우

대부분 이런 경우는 타입 선언 없이 라이브러리를 설치해 사용하다가 **뒤늦게 타입선언을 설치해서 사용할 때 발생**한다. 그 사이에 라이브러리와 타입 선언의 새 버전이 출시되었다면 라이브러리와 타입 선언의 버전이 어긋나게 된다. 해결책은 라이브러리의 버전과 타입 선언의 버전을 맞추는 것이다.

### Case3. 프로젝트에서 사용하는 타입스크립트 버전보다 라이브러리에서 필요로하는 타입스크립트 버전이 최신인 경우

유명한 자바스크립트 라이브러리들의 타입 정보를 더 정확하게 표현하기 위해서는 타입스크립트에서 타입시스템이 개선되고 버전이 올라가게 된다. 이러한 라이브러리들의 최신 타입 정보를 얻기 위해서는 당연히 타입스크립트의 최신버전을 사용해야 한다.

현재 프로젝트의 타입스크립트 버전보다 라이브러리의 버전이 높은 경우에는 `@types` 선언 자체에서 타입 오류가 발생하게 된다. 오류를 해결하기 위한 방법은 3 가지가 있다.

1. 타입스크립트 버전을 높인다.
2. 라이브러리 타입 선언 버전을 원래대로 내린다.
3. declare module 선언으로 라이브러리의 타입 정보를 없앤다.

라이브러리에서 [typesVersions](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html) 을 통해 타입스크립트 버전별로 다른 타입 선언을 제공하는 방법도 있지만 매우 드물다. typesVersions 은 실제로 매우 소수의 라이브러리에서만 제공하고 있다.

```json
{
  "name": "package-name",
  "version": "1.0.0",
  "types": "./index.d.ts",
  "typesVersions": {
    ">=3.1": { "*": ["ts3.1/*"] }
  }
}
```

라이브러리와 타입선언의 버전을 일치시키는 것이 최선이지만 타입선언을 제공하지 않는 라이브러리도 있다. 하지만 **유명한 라이브러리일 수록 타입 선언을 제공할 확률이 높다**.

### Case4. @types 의존성이 중복되는 경우

`@types/foo` 가 `@types/bar` 에 의존하고 있다고 가정해보자. 만약 `@types/bar` 가 현재 프로젝트와 호환되지 않는 `@types/foo` 에 의존하고 있다면 npm 은 중첩된 폴더에 별도로 해당 버전을 설치하여 문제를 해결하려고 한다.

```
/node_modules
	@types/
		foo/
			index.d.ts @1.2.3
		bar/
			index.d.ts
			node_modules/
				@types/
					foo/
						index.d.ts @2.3.4
```

런타임에 사용되는 모듈이라면 괜찮을 수 있지만, 전역 네임 스페이스 에 있는 타입 선언 모듈이라면 대부분 문제가 발생한다. 전역 네임스페이스에 타입 선언이 존재하면 중복된 선언 또는 선언이 병합될 수 없다는 오류로 나타나게 된다. 이런 상황에서는 `npm ls @types/foo` 명령으로 어디서 타입 선언 중복이 발생했는지 추적할 수 있다.

일부 라이브러리나 타입스크립트로 작성된 라이브러리들은 자체적으로 타입 선언을 번들링하게 된다. 자체적인 타입 선언은 보통 `package.json` 의 types 필드에서 `.d.ts` 파일을 가리키도록 되어 있다. 라이브러리가 타입스크립트로 작성되어 있고, 컴파일러를 통해 타입 선언이 생성된 경우라면 버전의 불일치 문제를 해결하긴 한다. 그러나 번들링 방식은 여러 문제를 가지고 있다.

**1. 번들된 타입 선언에 보강 기법으로 해결할 수 없는 오류가 있는 경우 or 공개 시점에는 잘 동작했지만 타입스크립트 버전에 올라가면서 오류가 발생하는 경우**

`@types` 를 별도로 선언하면 라이브러리 자체의 버전과 맞춰 해결할 수 있다. 그러나 번들된 타입에서는 `@types` 의 버전을 선택할 수 없다. 한개의 잘못된 타입 선언으로 인해 타입스크립트 버전을 올리지 못하는 불상사가 발생할 수 있다.

**2. 프로젝트 내의 타입 선언이 다른 라이브러리의 타입 선언에 의존**

보통 타입에 대한 의존성은 `devDependencies` 에 들어간다. 그러나 다른 사용자가 라이브러리를 설치하게 되면 `devDependencies` 가 설치되지 않을 것이고, 타입오류가 발생하게 된다.

**3. 프로젝트의 과거 버전에 있는 타입 선언에 문제가 있는 경우**

과거 버전으로 돌아가서 패치 업데이트를 해야 한다. 번들링된 타입 선언에서는 어렵지만, DefinitelyTyped 는 동일 라이브러리의 여러 버전의 타입 선언을 동시에 유지보수할 수 있는 매커니즘이 있다.

**4. 타입 선언의 패치 업데이트를 자주 실행하지 못함**

라이브러리 자체보다 타입 선언에 대한 패치 업데이트가 많은 이유는 DefinitelyTyped 는 커뮤니티에서 관리하기 때문에 가능하다. 만약 어떤 라이브러리 담당자가 타입에 대한 패치를 적용하지 않는다면 전체 유지보수 담당자가 패치를 하게 된다.

타입스크립트에서 의존성을 관리하는 것은 쉽지않지만, 잘 관리하면 충분한 보상이 존재한다. 타입 선언이 잘 작성되어 있다면 올바르게 사용할 수 있고, 생산성 역시 향상된다.

라이브러리를 공개하려고 한다면 타입 선언을 자체적으로 포함하는 것과 타입 정보만 분리하여 DefinitelyTyped 에 공개하는 것의 장단점을 비교해야 한다. 공식적으로는 **타입스크립트로 작성된 라이브러리인 경우 타입 선언을 자체적으로 포함**하는게 맞다.

**타입스크립트 컴파일러가 타입 선언을 자체적으로 생성**해주기 때문에, 타입스크립트로 작성된 라이브러리에 타입 선언을 포함하는 것은 문제가 없다. 만약 자바스크립트로 작성된 라이브러리는 손수 작성한 타입 선언을 오류가 있을 가능성이 높고 잦은 패치가 필요하다. 따라서 **자바스크립트로 작성된 라이브러리는 DefinitelyTyped 에 공개하여 커뮤니티에서 관리하고 유지보수** 할 수 있도록 하는 것이 좋다.
