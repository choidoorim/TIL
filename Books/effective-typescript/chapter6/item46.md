# 아이템46. 타입 선언과 관련된 세 가지 버전 이해하기

의존성 관리는 매우 어렵다. 타입스크립트는 알아서 의존성 문제를 해결해주기 보다는, 의존성 관리를 더 어렵게 만든다. 타입스크립트를 사용할 때는 3 가지의 사항을 추가로 고려해야 한다.

1. 라이브러리 버전
2. 타입 선언(`@types`) 버전
3. 타입스크립트 버전

3 가지 버전중에 하나라도 맞지 않다면 의존성과 상관없어 보이는 곳에서 엉뚱한 오류가 발생할 수 있다. 이렇게 발생된 오류를 해결하기 위해서는 타입스크립트의 복잡한 라이브러리 관리 매커니즘을 이해해야 한다.

타입스크립트에서 일반적으로 의존성을 사용하는 방법은 라이브러리를 `dependencies` 에 설치하고, 타입 정보는 `devDependencies` 로 설치한다.

```
$ npm install react
react@16.8.6

$ npm install --save-dev @types/react
@types/react@16.8.19
```

메이저와 마이너 버전(16.8)이 일치하지만 패치버전은 일치하고 있지 않다.

`@types/react` 의 `@16.8.19` 는 react 의 16.8.x 버전의 API 들을 지원한다는 뜻이다. 따라서 타입선언을 업데이트 할 필요는 없다.

그러나 실제 라이브러리와 타입 정보의 버전이 별도로 관리되는 방식은 4 가지의 문제점이 있다.

### Case1. 라이브러리는 업데이트했지만 타입 선언은 업데이트하지 않은 경우

라이브러리 업데이트와 관련된 **새로운 기능을 사용하려고 할 때마다 타입오류**가 발생하게 된다. 하위호환성이 깨지는 변경이 있었다면, 타입 체커에서 통과되었더라도 런타임에서 오류가 발생할 수 있다.

일반적인 방법으로는 타입 선언도 업데이트하면 된다. 하지만 타입 선언이 업데이트 되지 않았을 수도 있다. 이런 경우에는 보강기법을 활용하여 사용하려는 새 함수와 메서드의 타입 정보를 프로젝트에 추가하는 것이다. 또는 타입 선언의 업데이트가 필요한 부분을 직접 작성하고 공개하여 커뮤니티에 기여하는 방법도 있다.

### Case2. 라이브러리보다 타입 선언의 버전이 최신인 경우

대부분 이런 경우는 타입 선언 없이 라이브러리를 설치해 사용하다가 **뒤늦게 타입선언을 설치해서 사용할 때 발생**한다. 그 사이에 라이브러리와 타입 선언의 새 버전이 출시되었다면 라이브러리와 타입 선언의 버전이 어긋나게 된다. 해결책은 라이브러리의 버전과 타입 선언의 버전을 맞추는 것이다.

### Case3. 프로젝트에서 사용하는 타입스크립트 버전보다 라이브러리에서 필요로하는 타입스크립트 버전이 최신인 경우

유명한 자바스크립트 라이브러리들의 타입 정보를 더 정확하게 표현하기 위해서는 타입스크립트에서 타입시스템이 개선되고 버전이 올라가게 된다. 이러한 라이브러리들의 최신 타입 정보를 얻기 위해서는 당연히 타입스크립트의 최신버전을 사용해야 한다.

현재 프로젝트의 타입스크립트 버전보다 라이브러리의 버전이 높은 경우에는 `@types` 선언 자체에서 타입 오류가 발생하게 된다. 오류를 해결하기 위한 방법은 3 가지가 있다.

1. 타입스크립트 버전을 높인다.
2. 라이브러리 타입 선언 버전을 원래대로 내린다.
3. declare module 선언으로 라이브러리의 타입 정보를 없앤다.

라이브러리에서 [typesVersions](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html) 을 통해 타입스크립트 버전별로 다른 타입 선언을 제공하는 방법도 있지만 매우 드물다. typesVersions 은 실제로 매우 소수의 라이브러리에서만 제공하고 있다.

```json
{
  "name": "package-name",
  "version": "1.0.0",
  "types": "./index.d.ts",
  "typesVersions": {
    ">=3.1": { "*": ["ts3.1/*"] }
  }
}
```

라이브러리와 타입선언의 버전을 일치시키는 것이 최선이지만 타입선언을 제공하지 않는 라이브러리도 있다. 하지만 **유명한 라이브러리일 수록 타입 선언을 제공할 확률이 높다**.

### Case4. @types 의존성이 중복되는 경우

`@types/foo` 가 `@types/bar` 에 의존하고 있다고 가정해보자.
