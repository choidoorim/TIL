# Nestjs 로 API 만들기
## 1. Nestjs 란
Nodejs 위에서 동작하는 백엔드 프레임워크이다. NestJs 의 장점은 기존 다른 NodeJs 프레임워크에는 없는 구조를 가지고 있다.
예를 들면 Java 는 Spring, Python 은 Django 프레임워크처럼 순서와 구조를 가지고 있기에 그 틀에 맞춘다면 훌륭하고 안정적인 서비스를 만들수 있다.
NestJs 는 이러한 프레임워크의 특징들을 그대로 NodeJs 로 가져온 것이다.    
기존 NodeJs 는 내가 하고 싶은대로 구조를 짜고 설계가 가능하다는 장단점이 있다. 즉, 아무 룰도 따를 필요 없이 만들 수 있다는 뜻이다.
하지만 NestJs 는 그럴 수 없다. NestJs 는 순서와 규칙이 있는 구조가 있기 때문에 이를 따르기만 한다면 큰 규모의 백엔드를 쉽게 만들 수 있다.    

NestJs 는 100% typescript 를 기반으로 한다. 

해당 [링크](https://docs.nestjs.com/) 에서 NestJs 를 install 하면 된다.

## 2. NestJs 의 아키텍처
### 2-1. Overview
```typescript
@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
```

app.module.ts 의 위의 함수는 데코레이터라고 하는데 클래스에 함수 기능을 추가할 수 있게 한다.
클래스 위의 함수이고, 클래스를 위해 움직인다. 예를 들면 아이스크림 위에 뿌려지는 초콜릿 칩과 같다.

전체적인 흐름을 확인해보면 ```app.module.ts```, ```app.controller.ts``` , ```app.service.ts``` 순서로 데이터의 흐름이 이어진다.

```typescript
getHello(): string {
return this.appService.getHello();
}
```

위의 코드에서 ```getHello(): string``` 은 getHello 라는 메서드의 return 타입이 string 이라는 것이다. 

### 2-2. Controllers
NestJS 어플리케이션은 ```main.ts``` 에서부터 시작한다. 

```typescript
// main.ts
const app = await NestFactory.create(AppModule);
await app.listen(3000);
```

위의 코드에서 AppModule 에서 어플리케이션을 생성한다. 모듈이란 어플리케이션 전체의 일부분이다.
즉, 어플리케이션의 세부적인 기능들이라는 뜻이다. 

Controller 에서 하는 일은 기본적으로 **url 을 가져오고 함수를 실행**시키는 일을 한다.
express 에 비교하자면 Route 와 같은 것이다. 

```typescript
// app.controller.ts
@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get("/hello")
  getHello(): string {
    return this.appService.getHello();
  }
}
```

```javascript
// NodeJs - Express
router.get('/hello', (req, res, next) => {});
```

위의 코드를 보면 NestJs 의 **Get 데코레이터는 express 의 get Router** 와 같은 역할을 한다.
Get 데코레이터의 url 을 통해 해당 함수로 매핑을 하는 것이다.
이러한 NestJs 의 기능 덕분에 Route 를 셋팅하지 않아도 된다. ```@Get``` 을 통해서 get Request 를 얻을 수 있는 것이다. 

그런데 왜 Service 가 필요한 걸까? return 을 통해 한번에 이뤄질 수 있을텐데..

### 2-3. Service
NestJs 에서 Controller 는 단지 url 을 가져와서 함수를 실행시키는 역할만 한다. 나머지 비지니스 로직은 Service 에서 처리된다. 

```typescript
// app.controller.ts
@Get("/hello")
sayHello(): string {
    return this.appService.getHi();
}
```

controller 에서 url 을 가져와 service 함수를 실행시킨다.

```typescript
// app.service.ts
getHi(): string {
    return 'Hi Everyone';
}
```

service 에서는 비지니스 로직을 처리한다.

## 3. REST API
### 3.1 Controller
nest 의 generate 는 필요한 기능들을 생성해주는 기능을 한다.

terminal 에 ```nest``` 라는 커맨드를 실행시키면 아래 사진과 같이 나온다.

![1](https://user-images.githubusercontent.com/63203480/138225845-6205723a-440e-487b-9ffa-6cce35967b86.PNG)

generate 는 'g' 라는 옵션을 통해 사용이 가능하다.      
예를 들어 controller 를 생성하고 싶다면 ```nest g co``` 라는 커맨드를 통해 생성이 가능하다.    
User Controller 를 생성하기 위해서는 ```nest g co``` 커맨드 입력 후, ```user``` 라고 입력하면 생성된다.

```typescript
@Controller('user')
export class UserController {
    @Get()
    getAllUser(): string {
        return "return User Everyone";
    }
}
```

위 Controller 코드에서 @Controller 데코레이션의 user 라는 부분이 user 를 위한 url 을 만든다.    
코드를 로컬에서 실행시켰을 때 ```localhost:3000``` 이 아닌 ```localhost:3000/user``` 을 입력해야된다는 것이다.

- localhost:3000    
  
  ![1](https://user-images.githubusercontent.com/63203480/138229972-dc69c826-2634-46f0-a792-805e8047c0bd.PNG)


- localhost:3000/user    
  
  ![1](https://user-images.githubusercontent.com/63203480/138229841-0094a4ea-e5e6-4e47-b399-baed2b2337e0.PNG)
  
즉, ```@Controller``` 가 url 의 Entry Point 를 컨트롤 한다는 뜻이다.
- Entry Point: 코드가 실행될 때의 시작점

### url 의 파라미터 값 요청 후 받기

```typescript
@Get("/:id")
getUserId(@Param('id') id: string) {
    return `req id is ${id}`;
}
```

parmeter 의 decorator 를 사용하면 NestJs 는 url 에 있는 id parameter 를 원한다는 것을 알게 된다.    
Get 데코레이션의 id 와 Parameter 데코레이션의 id 는 같아야 한다. 하지만 ```id: string``` 의 id 는 달라고 된다.

```typescript
@Get("/:id")
getUserId(@Param('id') userId: string) {
    return `req id is ${userId}`;
}
```


### 3.2 More Routes
#### body 를 통해 데이터 받기
```@Body``` 데코레이터를 통해서 데이터를 받는다.
우리가 직접 파라미터를 요청을 해야만 값을 받아 사용할 수 있다.

```typescript
@Put("/:id")
updateUser(@Param('id') userId: string, @Body() updateData) {
  console.log(updateData);
  return {
    updateUserId : userId,
    ...updateData
  };
}
```

- ```...``` : 배열이나 객체의 데이터를 편하게 꺼내 쓸 수 있는 문법이다.
  위의 코드에서 ...updateData 를 updateData 로 할 경우 결과는 아래와 같다.
  ```
  {
    "updateUserId": "1",
    "updateData": {
        "name": "Doorim",
        "age": 25
    }
  }
  ```
  하지만 ```...``` 을 사용한다면 해당 객체 안에 값만을 사용하기 따문에 결과가 아래와 같다.
  ```
  {
    "updateUserId": "1",
    "name": "Doorim",
    "age": 25
  }
  ```
  
nestjs 는 기존 express 와 동일하게 search 부분이 get 보다 밑에 있으면 search 를 id 로 판단하는 문제가 있다. 즉, NestJs 가 ```search``` 를 ```:id``` 라고 생각하는 것이다.
예를 들면 ```/user/search``` 라는 api 와 ```/user/:id``` 라는 api 가 있을 때 코드 상 ```/user/:id``` 가 위에 있으면 ```/user/search``` 의 search 를 
parameter 로 판단하는 것이다.     

```typescript
// Err
@Get(":id")
getUserId(@Param('id') userId: string): string {
  return `req id is ${userId}`;
}

@Get("search")
search(){
  return `We are searching for a movie`;
}
```

```typescript
// OK
@Get("search")
search(){
  return `We are searching for a movie`;
}

@Get(":id")
getUserId(@Param('id') userId: string): string {
  return `req id is ${userId}`;
}
```

#### Query String 을 통해 데이터 받기
```@Query``` 데코레이션을 통해 QueryString 데이터를 받을 수 있다.

```typescript
@Get("search")
search(@Query("year") searchingYear: string){
    return `We are searching for a movie ${searchingYear}`;
}
```

### 3.3 Service
Service 는 하나의 기능에 대한 로직을 처리하는 역할을 한다.

#### Single responsibility-principle(단일 책임원칙)
하나의 module, class, function 이 하나의 기능을 책임을 져야하는 것이다.

