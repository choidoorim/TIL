# 연산자(Operator)
## 1. 연산자
### 1.1 연산자와 피연산자
- 연산자: 연산을 수행하는 기호(+, -, *, / ...)
- 피연산자: 연산자의 작업 대상(변수, 상수, 리터널, 수식)

연산자는 피연산자로 연산을 수행하고 나면 항상 결과 값을 반환한다. 예를 들어 x 의 값이 5 일 때, ```x + 3``` 의 결과 값은 8 이 된다.

### 1.2 식과 대입연산자
연산자와 피연산자를 조합하여 계산하고자하는 바를 표현한 것을 **식**이라고 한다. 그리고 식을 계산하여 결과를 얻는 것을 '식을 평가한다' 라고 한다.

### 1.3 연산자의 종류
- 산술 연산자(+, -, *, /, %, <<, >>) : 사칙연산(+, -, *, /)과 나머지 연산(%)
- 비교 연산자(>, <, >=, <=, ==, !=) : 크고 작음과 같고 다름을 비교
- 논리 연산자(&&, ||, !, &, |, ^, ~) : '그리고(and)', '또는(or)' 으로 조건을 연결
- 대입 연산자(=) : 우변의 값을 좌변에 저장
- 기타((type) ? : instanceof) : 형 변환 연산자, 삼항 연산자, instanceof 연산자

### 1.4 연산자의 우선순위와 결합규칙
식에서 사용된 연산자가 둘 이상인 경우, 연산자의 우선순위에 의해서 연산순서가 결정된다.

- ```-x + 3``` : 단항 연산자가 이상 연산자보다 우선순위가 높다. 따라서 x 의 부호를 바꾼다음 덧셈이 수행된다.
- ```x + 3 * y``` : 곱셈과 나눗셈이 덧셈과 뺄셈보다 우선순위가 높다. 그래서 '3 * y' 가 먼저 실행된다.
- ```x + 3 > y - 2``` : 비교 연산자(>) 보다 산술 연산자가 먼저 수행된다. 그래서 'x + 3' 과 'y - 2'가 먼저 계산된 다음에 '>' 가 수행된다.
- ```x > 3 && x < 5``` : 논리 연산자(&&) 보다 비교 연산자가 먼저 수행된다.
- ```result = x + y * 3``` : **대입 연산자는 연산자 중에서 제일 우선순위가 낮다**. 그래서 우변의 최종 연산결과가 변수 result 에 저장된다.

판단하기 어려운 우선순위 몇가지가 있다.
- ```x << 2 + 1``` : 쉬프트 연산자(<<)는 덧셈 연산자보다 우선순위가 낮다. 그래서 왼쪽의 식은 'x << (2 + 1)' 과 같다.
- ```data & 0xFF == 0``` : 비트 연산자(&) 는 비교 연산자(==)보다 우선순위가 낮으므로 비교연산 후에 비트연산이 수행된다. 그래서 왼쪽의 식은 'data & (0xFF == 0)' 과 같다.
- ```x < - 1 || x > 3 && x < 5``` : 논린 연산자 중에서 AND(&&) 가 OR(||) 보다 우선순위가 높다. 따라서 'x < - 1 || (x > 3 && x < 5)' 와 같다.

만약 우선순위가 확실하지 않다면, 먼저 계산되어야하는 부분을 괄호로 묶어주면 된다. **괄호 안의 계산식이 먼저 계산**된다.

#### 연산자의 결합규칙
우선순위가 같다고 해서 아무거나 먼저 처리하는 것은 아니고 나름대로의 규칙을 가지고 있는데, 그 규칙을 **연산자의 결합규칙** 이라고 한다.   
대부분 왼쪽에서 오른쪽의 순서로 연산을 수행하고, 단항 연산(++,--...)자와 대입 연산자(=)만 그 반대로, 오른쪽에서 왼쪽의 순서로 연산을 수행한다.   

연산자의 우선순위에 대해서 정리하면 다음과 같다.
1. 산술 > 비교 > 논리 > 대입.
2. 단항 > 이항 > 삼항
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.

### 1.5 산술 변환
이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능하기 때문에, 형 변환 연산자를 통해 타입을 일치시켜야 한다.

```java
int num1 = 10;
float num2 = 20.0f;

float result = (float)num1 + num2;  // 타입 일치
```

만약 **작은 타입에서 큰 타입으로 형 변환을 하는 경우 자동적으로 형변환**이 된다.

```java
int num1 = 10;
float num2 = 20.0f;

float result = num1 + num2;  // num1 자동 형 변환
```

산술 변환의 규칙은 아래와 같다.

1. 두 피연산자의 타입을 같게 일치시킨다.(큰 타입으로)
2. 피연산자의 타입이 int 보다 작은 타입이면 int 로 변환된다.
    - byte + short => int + int
    - char + short => int + int

## 2. 단항 연산자
### 2.1 증감 연산자 ++,--

증감연산자는 피연산자에 저장된 값을 1 증가 또는 감소시킨다. 증감연산자는 일반 산술 변환에 의한 자동 형변환이 발생하지 않는다.   
- 증가 연산자(++) : 피연산자의 값을 1 증가시킨다.
- 감소 연산자(--) : 피연산자의 값을 1 감소시킨다.

증가 연산자와 감소 연산자는 양쪽 모두 위치할 수 있다. 피연산자의 왼쪽에 위치하면 **전위형(prefix)**, 오른쪽에 위치하면 **후위형(postfix)** 라고 한다.

- 전위형(++i) : 값이 참조되기 전에 증가시킨다.
- 후위형(i++) : 값이 참조된 후에 증가시킨다.

그러나 '++i' 와 'i++' 처럼 증감연산자가 수식이나 메서드 호풀에 포함되지 않고 독립적인 하나의 문장으로 쓰인 경우에는 전위형과 후위형의 차이가 없다.   

```java
int i = 5;
i++;
System.out.println(i);  // 6

int j = 5;
++j;
System.out.println(j);  // 6
```

다른 수식에 포함되거나 메서드의 매개변수로 사용된 경우, 즉 단독으로 사용되지 않은 경우 전위형(++i)과 후위형(i++)의 결과는 다르다.

```java
package com.study;

public class Main {

    public static void main(String[] args) {
        int i = 5, j = 0;
        j = i++;    // i 의 값을 j 변수에 대입 한 후 i 를 증가시킨다.
        System.out.println("j=i++; 실행후, i =" + i +", j ="+ j);  // j=i++; 실행후, i =6, j =5

        i = 5;
        j = 0;

        j = ++i;    // i 의 값을 증가시킨 후, j 에 i 를 대입한다.
        System.out.println("j=i++; 실행전, i =" + i +", j ="+ j); // j=i++; 실행전, i =6, j =6
    }
}
```

전위형은 변수의 **값을 먼저 증가**시킨 후에 **변수의 값을 읽어오는** 반면, 후위형은 **변수의 값을 먼저 읽어온 후**에 **값을 증가**시킨다.   

```j = i++``` 연산은 아래와 같다.

```java
j = i;
i++;
```
 
### 2.2 부호 연산자 +,-
피연산자의 부호를 반대로 변경한 결과를 반환한다.

## 3. 산술 연산자
### 3.1 사칙 연산자 +,-,*,/
피연산자가 정수형인 경우, 나누는 수로 0 을 사용할 수 없다. 만약 0 으로 나눌 시 error 가 발생할 것이다.
나누기 연산(/)의 두 피연산자가 모두 int 타입인 경우, 연산결과 역시 int 타입이다. 그래서 ```10 / 4``` 연산 실행 시 결과는 2 이다.
이 때, 반올림이 발생하지 않는다는 것에 주의해야한다.    
올바른 연산결과를 얻기 위해서는 두 피연산중에서 한쪽을 실수형으로 형변환 해야 한다.  
```10 / 4.0f -> 10.0f / 4.0f -> 2.5f```

아래의 예제를 실행하면 컴파일 에러가 발생한다.

```java
public static void main(String[] args) {
    byte a = 10;
    byte b = 10;
    byte c = a + b;     
    System.out.println(c);
}
```

a, b 는 모두 int 형보다 작은 byte 형이기 때문에 연산자 '+' 는 2 개의 피연산자들을 int 형으로 변환한 뒤 연산을 수행한다.   
**크기가 작은 자료형의 변수를 큰 자료형의 변수에 저장할 때는 자동으로 형 변환(type conversion, casting)** 되지만, 
반대로 **큰 자료형의 값을 작은 자료형의 변수에 저장하려면 명시적으로 아래와 같이 형변환**을 해줘야한다.

```java
byte c = (byte)(a + b);  
```

아래의 예제를 실행하면 결과 값에 손실이 생긴다. 

```java
public static void main(String[] args) {
    byte a = 10;
    byte b = 30;
    byte c = (byte)(a * b);
    System.out.println(c);      // result : 44
}
```

300 은 byte 형의 범위를 넘기 때문에 byte 형으로 변환하면 데이터의 손실이 발생하여 결국 44 가 byte 변수 c 에 저장된다.   
byte(1 byte) 형에서 int(4 byte) 형으로 변환하는 것은 2 진수 8 자리에서 32 자리로 변환하는 것이기 때문에 자료 손실이 발생하지 않지만,
int 형을 byte 형으로 변환하는 경우 앞의 **24 자리를 없애고 하위 8 자리(1 byte) 만을 보존**하기 때문에 원래의 값이 보존되지 못한다.   

이미 오버플로우된 값은 아무리 형 변환을 하여 저장해도 소용이 없다. 

```java
int a = 1_000_000;
int b = 2_000_000;
long c = a * b;
System.out.println(c);      // -1454759936
```
올바른 결과를 얻기 위해서는 변수의 타입을 모두 형변환 해줘야 한다. 그리고 같은 의미의 식이라도 연산의 순서에 따라서 다른 결과를 얻을 수도 있으니 주의해야한다.   

아래의 예제를 컴파일 하면 오류가 발생하지 않고 실행도 올바른 결과를 얻는다. 왜 형변환을 해주지 않고도 문제가 없을까?
이항 연산자는 **int 보다 작은 타입의 피연산자를 int 로 자동 형 변환**하는데...

```java
char c = 'a' + 1;
System.out.println(c);  // b
```

그것은 바로 **리터럴 간의 연산**이기 때문이다. 상수 또는 리터럴 간의 연산은 실행 과정동안 변하는 값이 아니기 때문에, 컴파일 시에 컴파일러가 계산해서 그 결과로 대체함으로써 코드를 보다 효율적으로 만든다.   
그러나 **수식에 변수가 들어가 있는 경우**에는 컴파일러가 미리 계산을 할 수 없기 때문에 아래의 코드와 같이 형변환을 해줘야한다.

```java
char c1 = 'a';
// char result = c1 + 1;    // ERROR : 컴파일러가 미리 계산 불가능
char result = (char)(c1 + 1);
System.out.println(c);  // b
```

- ```Math.round(n)``` : 실수 n 을 반올림 할 수 있도록 도와주는 메서드

### 3.2 나머지 연산자 %
왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과로 반환하는 연산자이다. 나눗셈과 동일하게 나누는 수로 0 을 사용할 수 없다. 

```java
package com.study;

public class OperatorEx19 {
    public static void main(String[] args) {
        int x = 10;
        int y = 8;

        System.out.printf("몫은 %d, 나머지는 %d", x / y, x % y);      // 몫은 1, 나머지는 2
    }
}
```

## 4. 비교 연산자
두 피연산자를 비교하는 데 사용되는 연산자다.
### 4.1 대소비교 연산자 <,>,<=,>=
두 피연산자의 크기를 비교하는 연산자이다. 비교 결과가 **참이면 true**를, 거짓이면 **false**를 결과로 반환한다.
기본형 중에서 boolean 형을 제외한 나머지 자료형에 다 사용할 수 있지만 참조형에는 사용할 수 없다.

- ```>``` : 좌변 값이 크면 true, 아니면 false
- ```<``` : 우변 값이 크면 true, 아니면 false
- ```>=``` : 좌변 값이 크거나 같으면 true, 아니면 false
- ```<=``` : 우변 값이 크거나 같으면 true, 아니면 false

### 4.2 등가비교 연산자 ==,!=
두 피연산자의 값이 같은지 또는 다른지를 비교하는 연산자이다. 대소비교 연산자와는 다르게 모든 자료형에 사용할 수 있다.    
비교연산자도 이항 연산자이므로 연산을 수행하기 전에 형변환을 통해 두 피연산자의 타입을 같게 맞춘 다음 피연산자를 비교한다.

- ```==``` : 두 값이 같으면 true, 아니면 false
- ```!=``` : 두 값이 다르면 true, 아니면 false

#### 문자열의 비교
두 문자열을 비교할 때는, 비교 연산자 ```==``` 대신 ```equals()``` 라는 메서드를 사용해야 한다. 비교 연산자는 두 문자열이 완전히 같은 것인지
비교할 뿐이므로, 문자열의 내용이 같은지를 비교하기 위해서는 ```equals()``` 를 사용하는 것이다.
만일 대소문자를 구별하고 싶지 않다면 ```equalsIgnoreCase()``` 메서드를 사용하면 된다.

## 5. 논리 연산자
"4 보다 작거나 또는 10 보다 크다" 라는 두 개의 조건이 결합된 경우에 사용하는 것이 논리 연산자이다.

### 5.1 논리 연산자 &&, ||
'&&' 은 우리말로 '그리고(AND)' 에 해당하며, 두 피연산자가 모두 true 일 때만 true 를 결과로 얻는다.   
'||' 는 우리말로 '또는(OR)' 에 해당하며, 두 피연산자 중 어느 한 쪽만 true 이어도 true 를 결과로 얻는다.

1. x 는 10 보다 크고, 20 보다 작다.
```x > 10 && x < 20```
   
2. i 는 2의 배수 또는 3의 배수이다.
```i % 2 == 0 || i % 3 == 0```
   
3. 문자 ch 는 숫자('0' ~ '9') 이다.
``` '0' <= ch && ch <= '9' ```

#### 효율적인 연산
OR 연산의 경우, 두 피연산자 중 어느 한 쪽만 참이어도 전체 연산결과가 참이므로 좌측 피연산자가 참이면, 우측 피연산자의 값은 평가하지 않는다.    
AND 연산의 경우도 마찬가지로 어느 한쪽만 거짓이어도 전체 연산결과가 거짓이므로 좌측 피연산자가 거짓이면, 우측 피연산자는 평가하지 않는다.

**그래서 같은 조건식이라도 피연산자의 위치에 따라서 연산속도가 달라질 수 있는 것이다**. OR 연산의 경우에는 연산결과가 true 일 확률이 높은 피연산자를 연산자의 왼쪽에 놓고,
AND 연산의 경우에는 연산결과가 false 일 확률이 높은 피연산자를 왼쪽에 놓아야 더 빠른 연산결과를 얻을 수 있다.

#### 논리 부정 연산자 : !
이 연산자는 피연산자가 true 이면 false 를, false 이면 true 결과로 반환한다. 간단히 말해 true 와 false 를 바꾸는 것이다. 

### 5.2 비트 연산자 &, |, ^, ~, <<, >>
비트 연산자는 피연산자를 비트단위로 논리 연산한다. 피연산자로 실수는 허용하지 않는다. 문자 포함, 정수만 허용된다.

- ```|```(OR) : 피연산자 중 한 쪽의 값이 1이면, 1을 결과로 얻는다. 그 외에는 0 을 얻는다.
- ```&```(AND) : 피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다. 그 외에는 0을 얻는다.
- ```^```(XOR) : 피연산자의 값이 서로 다를 때만 1을 결과로 얻는다. 같을 때는 0을 얻는다.

```java
package com.study;

public class OperatorEx28 {
    public static void main(String[] args) {
        int x = 0xAB, y = 0xF;
        System.out.printf("x = %#X \t\t%s%n", x, toBinaryString(x));
        System.out.printf("y = %#X \t\t%s%n", y, toBinaryString(y));
        System.out.printf("%#X | %#X = %#X \t%s%n", x, y, x | y, toBinaryString(x));
        System.out.printf("%#X & %#X = %#X \t%s%n", x, y, x & y, toBinaryString(x));
        System.out.printf("%#X ^ %#X = %#X \t%s%n", x, y, x ^ y, toBinaryString(x));
        System.out.printf("%#X ^ %#X ^ %#X = %#X \t%s%n", x, y, y, x ^ y ^ y, toBinaryString(x));
    }
    
    // 10 진수 정수를 2 진수로 변환
    static String toBinaryString(int x) {
        String zero = "00000000000000000000000000000000";
        String tmp = zero + Integer.toBinaryString(x);
        return tmp.substring(tmp.length() - 32);
    }
}
```

#### 비트 전환 연산자 : ~
피연산자를 2진수로 표현했을 때, 0은 1로, 1은 0으로 바꾼다. 논리부정 연산자 '!' 와 유사하다.

#### 쉬프트 연산자 : <<, >>
이 연산자는 피연산자의 각 자리를 오른쪽, 왼쪽으로 이동한다고 해서 쉬프트 연산자라고 한다.    
자리이동을 할 때 저장범위를 **벗어난 값들은 버려지고 빈자리는 0** 으로 채워진다. 만약 음수 일 경우는 빈자리를 1로 채운다.

곱셈이나 나눗셈 연산자를 사용하면 쉬프트 연산과 같은 결과를 얻을 수 있는데 굳이 사용하는 이유는 바로 속도 때문이다.
즉,  '>>' 또는 '<<' 연산자를 사용하는 것이 나눗셈(/) 또는 곱셈(*) 연산자를 사용하는 것보다 더 빠르다.   
실행속도도 중요하지만 가독성도 상당히 중요하기에 보다 **빠른 실행속도가 요구되어지는 곳만 쉬프트 연산자를 사용**하는 것이 좋다.

## 6. 그 외 연산자
### 6.1 조건 연산자 : ?
조건 연산자는 조건식, 식1, 식2 모두 세 개의 피연산자를 필요로 하는 삼항 연산자이며, 삼항 연산자는 조건 연산자 하나뿐이다.
```
조건식 ? 식1(true) : 식2(false)
```
조건식의 평가결과가 true 이면 식1이 false 이면 식2가 연산결과가 된다. 가독성을 높이기 위해 조건식을 괄호()로 둘러싸는 경우가 많지만 필수는 아니다.
```java
result = (x > y) ? x : y;
```
조건 연산자를 사용하는 것이 if 문보다 간략하다.   
조건 연산자를 중첩해서 사용하면 셋 이상 중의 하나를 결과로 얻을 수 있다. 아래의 식은 x 의 값이 양수면 1, 0 이면 0, 음수면 -1, 즉 셋 중의 하나를 결과로 반환한다. 
```java
result = (x > 0) ? 1 : (x == 0 ? 0 : - 1)
```

### 6.2 대입 연산자 ==, op=
대입 연산자는 변수와 같은 저장공간에 값 또는 수식의 연산결과를 저장하는데 사용된다. 이 연산자는 오른쪽 피연산자의 값을 왼쪽 피연산자에 저장한다.    
대입 연산자는 연산자들 중에서 **가장 낮은 우선순위**를 가지고 있기 때문에 식에서 제일 나중에 수행된다. 

#### lvalue 와 rvalue
대입 연산자의 왼쪽 피연산자를 'lvalue' 라고 하고, 오른쪽 피연산자를 'rvalue' 라고 한다.
```
x(lvalue) = 3(rvalue)
```

변수 앞에 키워드 **'final'** 을 붙이면 상수가 된다. 상수에 한 번 저장된 값은 바꿀 수 없다. 

#### 복합 대입 연산자
대입 연산자는 다른 연산자(op)와 결합하여 'op='와 같은 방식으로 사용될 수 있다.

- ```i = i + 3;``` -> ```i += 3;```
- ```i = i * (10 + j);``` -> ```i *= 10 + j;```
