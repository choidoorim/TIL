# 객체지향 프로그래밍 II
# 1. 상속
상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것입니다. 상속을 통해서 클래스를 작성하면 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있고,
코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경이 용이합니다.       
이러한 특징 덕분에 재사용성을 높이고, 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여합니다.

자바에서 상속을 구현하기 위해서는 상속 받고자하는 클래스에 ```extends``` 와 함께 써주면 됩니다.

```java
class Child extends Parent {
    //...    
}
```

- 조상클래스: 상속해주는 클래스, 부모(parent) 클래스, 상위(super) 클래스, 기반(base) 클래스
- 자손 클래스: 상속 받는 클래스, 하위(sub) 클래스, 파생된(derived) 클래스

상속을 받는 것은 조상 클래스를 확장(extend) 한다는 의미이기 때문에 상속에 사용되는 키워드가 ```extends``` 인 이유기도 합니다.

- 생성자와 초기화 블럭을 상속되지 않고, 멤버만 상속됩니다.
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 많거나 같습니다.

조상 클래스를 변경하게 된다면 모든 자손 클래스에, 자손의 자손 클래스에까지 영향을 미치기 때문에 클래스간의 상속관계를 맺어 주면 
**자손 클래스들의 공통적인 부분은 조상클래스에서 관리하고 자손 클래스는 자신에 정의된 멤버들만 관리**하면 되므로 각 클래스의 코드가 적어져서 관리가 쉬워집니다.

자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성됩니다.

## 클래스간의 관계 - 포함관계
상속 이외에도 클래스를 재사용할 수 있는 방법으로 **클래스 간에 포함관계를 맺어주는 것**입니다.

```java
class Point {
    int x;
    int y;
}
class Circle {
    Point c = new Point();
    int r;
    //  int x; 
    //  int y;
    //  int r;
}
```

## 클래스간의 관계 설정하기
클래스 작성 시 상속관계를 설정할 지 포함관계를 설정할 지 헷갈릴 수가 있습니다. 
그럴 때는 아래와 같이 문장을 만들어보면 쉽게 해결할 수 있습니다.

- 상속 관계 : ```~은 ~ 이다.(is-a)```, ex) SportsCar 는 Car 이다.
- 포함 관계 : ```~은 ~ 을 가지고 있다.(has-a)```, ex) Deck 은 Card 를 가지고 있다.

조상 클래스에 정의된 메서드와 같은 메서드를 자손 클래스에 재정의하는 것을 **오버라이딩** 이라고 합니다.

## 단일 상속
자바에서는 다중상속을 지원하지 않습니다. 
```java
class TVCR extends TV, VCR {
    //...
}
```

- 장점: 복합적인 기능을 가진 클래스를 쉽게 작성할 수 있습니다.
- 단점: 클래스 간의 관계가 상당히 복잡해진다는 것과 서로 다른 클래스로부터 상속받은 멤버간의 이름이 같은 경우 구별할 수 있는 방법이 없습니다.

다중상속의 단점때문에 지원하지 않지만 조상 클래스에 포함시켜 여러 개의 클래스를 사용할 수 있습니다.
```java
class Tv {
    boolean power;
    int channel;
    //...
}

class VCR {
    boolean power;
    int counter = 0;
    void power() { power = !power; }
    void play() { /* ... */ }
    //...
}

class TVCR extends Tv {
    VCR vcr = new VCR();
    
    void play() { 
        vcr.play();
    }
    //...
}
```

자바 모든 클래스들은 Object 클래스의 멤버들을 상속 받기 때문에 Object 클래스에 정의된 멤버들을 사용할 수 있습니다.

```java
class Tv extends Object {
    //...
}
```

# 2. 오버라이딩
조상 클래스로부터 **상속 받은 메서드의 내용을 변경하는 것**을 오버라이딩이라고 합니다.

```java
class Point {
    int x;
    int y;
    
    String getLocation() {
        return "x: "+ x + ", y: " + y;
    }
}

class Point3D extends Point {
    int z;
    
    String getLocation() {
        return "x: "+ x + ", y: " + y + ", z: " + z;
    }
}
```

### 오버라이딩의 조건
```
자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
- 이름이 같아야 한다
- 매개변수가 같아야 한다
- 반환타입이 같아야 한다.
```

#### 1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없다.
만약 조상 클래스에서 정의된 메서드의 접근 제어자가 protected 라면, 이를 오버라이딩하는 자손 클래스의 메서드는 접근 제어자가 protected 난 public 이어야 한다.
대부분의 경우에는 같은 범위의 접근 제어자를 사용합니다. 
- 접근 제어자의 접근 범위: public -> protected -> default -> private

#### 2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.(적거나 같으면 안된다)
```java
class Parent {
    void parentMethod() throws IOException, SQLException {

    }
}

class Child extends Parent {
    void parentMethod() throws Exception {  // ERROR
        
    }
}
```
```Exception``` 은 모든 예외의 최고 조상이므로 가장 많은 개수의 예외를 던질 수 있습니다.
따라서 위의 코드는 2 번 조건에 위반하므로 오버라이딩이 되지 않습니다.
    
#### 3. 인스턴스메서드를 static 메서드로 또는 그 반대로 변경할 수 없습니다.

## 오버로딩 vs. 오버라이딩
- 오버로딩: 기존에 없는 새로운 메서드를 정의하는 것(new)
- 오버라이딩: 상속받은 메서드의 내용을 변경하는 것(change, modify)

## super
super 란 자손 클래스에서 **조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수**입니다.    
멤버변수와 지역변수의 이름이 같을 때 ```this``` 를 붙여서 구별했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을 때는 super 를 붙여서 구별할 수 있습니다.
조상 클래스의 멤버와 자손클래스의 멤버가 중복 정의되어 서로 구별되야 할 경우에만 ```super``` 를 사용하는 것이 좋습니다.
조상의 멤버와 자신의 멤버를 구별하는데 사용된다는 점을 제외하고는 **super 와 this 는 근본적으로 같습니다**.

```java
public class SuperTest {
    public static void main(String[] args) {
        ChildTest c = new ChildTest();
        c.PrintVariableMethod();
    }
}

class ParentTest {
    int x = 10;
}

class ChildTest extends ParentTest {
    int x = 20;
    void PrintVariableMethod() {
        System.out.println("x =" +x);
        System.out.println("this.x =" +this.x);     // 20
        System.out.println("super.x =" +super.x);   // 10
    }
}
```

변수뿐만이 아니라 메서드 역시 ```super```를 통해 호출할 수 있습니다. 특히 조상 클래스의 메서드를 자손 클래스에서 오버라이딩한 경우에 사용합니다.

```java
//...
class ChildTest extends ParentTest {
    String method() {
        return super.method() + ", z: " + z;
    }
}
```

### super() - 조상 클래스의 생성자
Object 클래스를 제외한 모든 클래스의 생성자 첫 줄에 생성자, this() 또는 super(), 를 호출해야 합니다.
그렇지 않으면 **컴파일러가 자동적으로 ```super();``` 를 생성자의 첫 줄에 삽입**합니다.

```java
class PointTest {
    int x = 10;
    int y = 20;

    PointTest(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

class Point3DTest extends PointTest {
    int z = 30;
    Point3DTest() {
        this(100, 200, 300);
    }

    Point3DTest(int x, int y, int z) {
        super(x, y);    // 조상클래스의 생성자 PointTest(int x, int y) 를 호출
        this.z = z;
    }
}
```

조상 클래스의 멤버변수는 조상의 생성자에 의해 초기화되도록 해야 합니다.

# 3. package 와 import
## Package 
패키지란 **클래스의 묶음**입니다. 서로 관련된 클래스끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리할 수 있습니다.
같은 이름의 클래스라도 다른 패키지에 존재하는 것이 가능하여 서로 다른 개발자끼리 개발한 라이브러리의 클래스와 이름이 충돌하는 것을 피할 수 있습니다.    
**클래스가 물리적으로 하나의 클래스파일(.class) 인 것과 같이 패키지는 물리적으로 하나의 디렉토리입니다**.     

```package 패키지명;``` 으로 선언할 수 있습니다. 컴파일 시 지정된 패키지 경로에 디렉토리가 존재하지 않을 경우 자동으로 생성해줍니다.


# 4. 제어자
# 5. 다형성
# 6. 추상클래스
# 7. 인터페이스
# 8. 내부 클래스
