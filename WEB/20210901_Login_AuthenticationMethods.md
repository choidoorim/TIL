우리가 어플리케이션을 사용할 때 매번 로그인을 하지 않고 어플리케이션을 인증할 수 있는 이유가 무엇일까?

그것는 바로 로그인 인증방법을 통해 추가적인 인증 없이 사용할 수 있는 것이다.

인증 방식을 크게 나누면 **서버인증 방식**과 **토큰인증 방식**이 있다.

### 서버인증 방식

> **1. 쿠키&세션 방식**

HTTP 프로토콜의 단점인 connectionless 와 stateless 를 해결하기 위한 방식입니다.

#### 쿠키란?

-   key 와 value 값이 들어있는 작은 데이터로 서버를 사용하고 있는 **클라이언트의 컴퓨터에 저장**된다.
-   인증 유효시간을 지정할 수 있고, 브라우저가 종료되더라고 인증이 유지된다는 특징이 있다.
-   Response Header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있습니다.

#### 세션이란?

-   웹 서버에 접속해 있는 사용자의 상태를 말한다.
-   쿠키를 기반으로 하지만, 사용자의 정보 데이터를 클라이언트 로컬이 아닌 **서버에 저장**합니다.
-   클라이언트에게 인증에 필요한 ID인 세션 ID를 부여한다.

기본적으로 서버에 세션 저장소가 필요하다.

클라이언트가 로그인 요청(Request)을 보냈을 경우 서버 세션 저장소에서 세션 ID(SSID)를 만들어 클라이언트에게 응답(Response)해준다.

클라이언트는 받은 **세션 ID를 쿠키로 저장하고 있다가 인증이 필요할 때마다 매번 서버의 세션 ID와 매칭**한다. 쿠키에 대한 요청과 응답은 패킷의 **Header에 담아 전송**한다.

요새 주로 사용되는 인증 방식은 아니라고 한다.

#### 장점

1. 로그인 시 사용자 고유의 세션 ID를 부여받게 되므로 서버 입장에서는 매번 회원정보를 확인 할 필요가 없기에 서버의 리소스에 접근하는데 용이하다.

 만약 통신 중 쿠키가 노출된다고 하더라도 쿠키자체는 유의미한 데이터를 담고 있지 않기에 계정정보를 담아 인증하는 방식에 비해서는 보안이 좋다.

#### 단점

1. 클라이언트가 세션 ID를 가지고 있기 때문에 의존적이다.

2. 세션은 사용자 수만큼 서버 메모리를 차지하기 때문에 서버에 부하가 생길 수 있다.

3. 쿠키가 해킹 당했을 경우 세션 하이재킹 공격에 취약할 수 있다.

4. 확장성이 좋지 않다 - 서버가 여러개 일경우 서버1에서 로그인 후 서버2에 접근을 해야 될 경우 인증이 되지 않는다.

---

### 토큰인증 방식

> **2. OAuth(Open Auth) 방식** 

소셜 로그인 시 사용되는 방식이다.

클라이언트에게 제한된 권한만 주고 유효기간이 끝날 경우 재발급을 해야하는 방식으로 카카오, 네이버, 구글 등 대형 회사에서 자신들의 정보의 일부에 대한 권한을 부여하여 정보를 공유할 수 있도록 허용해주는 것이다.

예를 들면 어플리케이션의 로그인 기능을 구현할 때 카카오, 네이버등 로그인 API를 통해 카카오, 네이버등 대형 어플리케이션을 사용하는 유저의 정보를 동의를 구한 후 일부 사용할 수 있는 것과 같다.

![1](https://user-images.githubusercontent.com/63203480/131634051-f9291378-e103-4bc8-beec-9a00a6bf2275.png)


* Access Token 발급 전에 유효 기간이 긴 Refresh Token을 발급 해준 후 Refresh Token을 보유하고 있는 클라이언트에게 Access Token을 보내준다.

* Access Token은 유효기간이 짧기 때문에 서비스 사용 시 매번 발급받아야 한다.

* Refresh Token을 가지고 있다는 가정

1. 클라이언트가 카카오 ID, PW + 선택 필수 등 정보를 입력 후 카카오 서버에 요청한다.

2. 카카오 서버에서 확인 후 Access Token을 클라이언트에게 응답하여 보내준다.

3. 클라이언트는 Access Token을 나의 서버에 전달해준다.

4. 나의 서버는 클라이언트에게 받은 Access Token을 카카오 서버에 보내 맞는지 확인을 한다.

5. 맞다면 카카오 서버에서 사용자의 정보와 함께 응답을 할 것이고, 맞지 않는다면 카카오 서버에서 오류 응답을 해줄 것이다. 나의 서버에서는 받은 정보를 통해 활용하면 된다.

6. Access Token을 통해 카카오 서버와 나의 서버가 통신 한 정보에 대해 클라이언트에게 응답해준다.

### 장점

인증 과정이 많기 때문에 보안이 매우 뛰어나다.

### 단점

직접 Open Auth 방식을 구현 시 구현이 까다롭고, 인증 과정이 많기에 서버에 부하가 클 수 있다.

> **3. JWT(JSON Web Token) 방식**

인증에 필요한 정보들을 암호화한 토큰들을 사용하는 방식이다.

사용자 인증에 필요한 정보를 암호화한 토큰을 세션/쿠키 방식과 유사하게 패킷의 Header에 담아 전송하여 인증을 확인한다.

예를 들면 놀이공원의 자유이용권과 같은 개념이다. 자유이용권 티켓을 발급받으면 놀이기구를 탈 때마다 티켓만 가지고 있다면 인증 후 여러 놀이기구를 탈 수 있는 것과 같다.

![1](https://user-images.githubusercontent.com/63203480/131634371-1ae17149-2beb-4d85-9932-c41da66366ca.png)

1. 클라이언트가 ID, PW와 같은 인증에 필요한 정보를 담아 서버에게 보내준다.

2. 서버는 받은 정보를 토대로 암호화 된 JWT 토큰을 만들어 클라이언트에게 보내준다.

3. 클라이언트는 JWT 토큰을 가지고 있으면 Hearder 에 토큰을 담아 서버에 보내면서 인증을 계속 한다.

### JWT 구조

Header: Token 의 Type

Payload: 사용자를 식별 할 수 있는 유추가능한 데이터

Signature: 서버의 키 값 + Header + Payload 값을 암호화

![1](https://user-images.githubusercontent.com/63203480/131634457-eebdfc7a-3841-485b-b481-716e9e8b39a2.png)

### 장점

1. 클라이언트에서 암호화 된 토큰을 가지고 있다가 서버에게 보내며 인증하므로 저장소가 별도로 필요하지 않다.

2. 확장성이 좋다.

### 단점

1. 한번 발급 된 JWT 토큰은 유효기간이 끝나기 전까지는 계속 사용이 가능하다. 이 말은 여러 토큰이 발급될 수 있다는 것이다. 만약 토큰이 탈취 될 경우 해당 토큰을 활용해 유효기간이 끝나기 전까지 사용자의 정보를 털어갈 수 있다.

2. Payload 정보가 제한적으로 유저의 중요한 정보를 Payload에 담을 수 없다. 또한 Payload 정보는 디코딩으로 알 수 있기 때문에 유저의 중요한 정보를 담으면 안된다.
