# Section2 - 이미지 & 컨테이너: 코어 빌딩 블록
# 이미지와 컨테이너 - 무엇이며, 왜 사용할까?
컨테이너는 어플리케이션, 웹 사이트, 노드 서버, 실행 환경 등 어떤 것이든 포함하는 작은 패키지다.

이미지는 컨테이너를 위한 템플릿, 블루프린트(노드를 연결하여 프로그램의 논리를 표현) 이다. 이미지는 실제로 코드와 코드를 실행하는데 필요한 도구를 포함한다. 그 다음 컨테이너가 실행되어 코드를 실행한다.    
즉, 이미지는 모든 설정관련 명령어와 모든 코드가 포함된 **공유 가능한 패키지**다.   
그리고 컨테이너는 이러한 **이미지의 구체적인 실행 인스턴스**다.

<img width="969" alt="스크린샷 2022-05-25 오전 11 58 38" src="https://user-images.githubusercontent.com/63203480/170170542-aa29f792-4d4a-4392-b674-95f90aa81414.png">

이미지를 기반으로 하는 컨테이너를 실행시키는 것이 기본적인 도커의 개념이며 모든 것이라고 볼 수 있다.

# 외부 이미지의 사용 및 실행
컨테이너를 실행할 수 있도록 이미지를 생성하고 가져오는 방법이 있다.

### 1. 이미 존재하는 이미지를 사용한다.
기본적으로 팀 또는 개인이 구축해놓은 이미지를 사용할 수 있다. 그리고 그 이미지를 기반으로 컨테이너를 생성할 수 있다.    
예를 들면 Docker Hub 에 있는 ```node``` 이미지를 사용할 수 있다.    
```docker run node```

기본적으로 컨테이너는 주변 환경과 격리되어 있기에 노드를 이미지로 실행하거나 노드 이미지를 기반으로 하는 컨테이너로 실행했어도 이것만으로는 별 의미가 없다.     
노드 기반 컨테이너를 실행하고 사용하기 위해서는 노드 명령어를 실행할 수 있는 인터렉티브 노드 터미널에 들어가야 한다.    
```docker run -it node```

이미지는 컨테이너에 필요한 모든 논리와 모든 코드를 보관하는데 사용하는 것이며, ```run``` 명령어를 사용해서 이미지의 인스턴스를 만든다.
그리고 이것은 이미지를 기반으로 하는 구체적인 컨테이너를 생성한다.

### 2. 자신만의 커스텀 이미지를 만든다.
일반적으로 공식 베이스 이미지를 가져온 다음 그 위에 코드를 추가하여 그 이미지로 코드를 실행한다.

# Dockerfile 을 사용하여 자체 이미지 빌드하기
```Dockerfile``` 이라는 파일명은 도커에 의해서 식별되는 이름입니다.   
이 파일에서는 자체 이미지를 빌드할 때 실행하려는 도커에 대한 명령들이 포함된다.

일반적으로는 ```FROM``` 명령으로 시작한다. 이를 통해서 다른 기본 이미지에 우리의 이미지를 구축할 수 있게 된다.   
이름에는 내 시스템에 존재하거나 도커 허브 상의 이미지명을 넣는다.
```dockerfile
# node - 도커 허브 이미지, node 라는 이름의 이미지가 존재하기에 가능
# 도커에게 노드 이미지를 가지고 오는 것으로 시작한다라고 말하는 것
FROM node
```
만약 node 이미지를 기반으로 컨테이너를 실행했다면 이 이미지가 로컬에 다운로드 및 캐시되었기 때문에 실제로 해당 이미지를 기반으로 컨테이너를 실행하는 순간 로컬에도 존재하게 된다.

그 다음 단계로 도커에게 로컬 머신에 있는 어떤 파일이 이미지에 들어가야 하는지 알려야 한다.
이것은 ```COPY``` 명령을 사용한다. 매우 간단한 명령으로는 ```COPY . .``` 이다.    
COPY 는 2가지의 경로를 지정합니다.
1. 컨테이너의 외부, 이미지의 외부 경로이며 이미지로 복사되어야 할 파일들이 있는 곳이다. 컨테이너 또한 이미지는 환경과 코드를 갖고 있고 거기서 실행되는 것을 기억하자.
    - 만약 ```.``` 일 경우 도커에게 기본적으로 Dockerfile 이 포함된 동일한 폴더임을 알리는 것이다. 즉, 이 프로젝트의 모든 폴더, 하위 폴더 및 파일을 복사해야 한다고 도커에게 알리는 것이다.
2. 첫번째에 복사해야할 파일들을 저장하는 이미지 내부의 경로이다.
    - 모든 이미지와 이미지를 기반으로 생성된 모든 컨테이너에는 로컬 파일시스템에서 완전히 분리된 자체 내부 파일 시스템이 있다. 이것은 도커 컨테이너 내부에 숨겨져 있다.
    - 만약 ```COPY . /app``` 으로 한다면 로컬에 파일들이 컨테이너 내부의 app 폴더에 복사되는 것이다. 만약 폴더가 없을 경우에는 이미지와 컨테이너에 생성된다.
```dockerfile
FROM node

COPY . /app
```

노드같은 경우에는 모든 종속성들을 설치하기 위해 ```npm install``` 을 실행했어야 되기 때문에 이미지에 명령어 ```RUN``` 하고 싶다고 알릴 수 있다.
```dockerfile
FROM node

COPY . /app

RUN npm install
```
기본적으로 이러한 모든 명령은 도커 컨테이너 및 이미지의 작업 디렉토리에서 실행된다.

도커에게 모든 명령 실행과정은 어떤 디렉토리에서 진행해야 한다고 알려줄 수 있는 방법이 있다. 바로 ```WORKDIR``` 명령을 사용하면 된다.   
이것은 도커 컨테이너의 작업 디렉토리를 설정하는 명령이다.
```dockerfile
FROM node

WORKDIR /app

COPY . /app

RUN npm install
```
이렇게 지정한다면 후속 명령어들이 모두 ```/app``` 이라는 작업 디렉토리에서 실행된다는 것이 된다.   
그리고 작업 디렉토리를 ```/app``` 으로 설정했다는 사실을 감안해서 로컬에 파일이 복사되는 경로를 ```./``` 으로 변경할 수 있다. ```./``` 은 도커 컨테이너의 현재 작업 디렉토리를 의미한다.
```dockerfile
FROM node

WORKDIR /app

COPY . ./
# COPY . /app - 절대 경로를 지정해줘도 상관없다
# 절대경로로 명시하여 파일을 복사할 위치를 명확히 알 수 있게되고 현재 작업 디렉토리가 무엇인지 명확하여 더 좋을 수 있다.

RUN npm install
```

마지막으로 설정이 끝났다면 어플리케이션을 실행시키는 명령어를 실행해야 한다.
```RUN``` 명령어는 이미지가 빌드될 때마다 실행되는 것이기에 올바르지 않다.   
컨테이너를 시작하는 경우에만 서버를 시작하고 싶은 것이기에 ```CMD``` 명령을 사용하면 된다.
```RUN``` 명령어와 차이가 있다면 ```CMD``` 는 이미지가 생성될 때 실행되는 것이 아닌 **이미지를 기반으로 컨테이너가 시작**될 때 실행된다.
```dockerfile
FROM node

WORKDIR /app

COPY . /app

RUN npm install

CMD npm run start
```

만약 노드 웹서버가 3000 포트에서 수신 대기하고 있다고 가정해보자. 컨테이너 내부의 노드 어플리케이션에서 3000 포트를 수신할 때, 컨테이너는 그 포트를 우리의 로컬에 노출하지는 않는다.   
따라서 컨테이너 내부에서만 무언가를 수신 대기 중이기에 3000 포트에서 수신이 불가능하다.  
그래서 언제나 Dockerfile 의 마지막 명령 전에 우리의 로컬 시스템에 특정 포트를 노출하고 싶다는 것을 도커에게 알리는 ```EXPOSE``` 명령을 사용해야 한다.
```dockerfile
FROM node

WORKDIR /app

COPY . /app

RUN npm install

EXPOSE 3000

CMD npm run start
```

# 자체 이미지를 기반으로 컨테이너 실행하기
자체 커스텀 이미지를 만들기 위해서는 ```docker build``` 명령을 통해 실행한다.   
```docker build``` 명령 다음 문구에 ```Dockerfile``` 이 어디에 있는지 알려줘야 한다.    
예를 들면 아래의 명령은 현재 실행하려는 빌드 명령기준 현재 디렉토리 위치에 도커파일이 있다는 뜻입니다.
```text
$ docker build .
```
빌드된 이미지 ID와 ```docker run 이미지ID```명령을 사용해서 컨테이너를 실행시킬 수 있습니다.

컨테이너를 실행 시키면 서버를 실행시키는 것과 같다. 하지만 Dockerfile 에 포트를 노출했음에도 불구하고 접속이 되지 않는다. 그 이유는, Dockerfile 에는 ```EXPOSE``` 명령을 통해 포트를 노출시켰지만 사실 이 명령은 documentation 목적으로만 추가되었기 때문이다.
즉, ```Dockerfile``` 을 통해 ```EXPOSE``` 명령을 통해 포트를 노출해도 아무 것도 하지 않는 것이다. 따라서 ```EXPOSE``` 명령은 필수가 아닌 선택 사항이다.
하지만 일반적으로는 ```EXPOSE``` 명령을 통해 문서화 하는 것이 모범적인 사례이다.      
위의 문제를 해결하기 위해서는 ```docker run``` 명령을 수행할 때 ```-p``` 플래그를 추가해줘야 한다. 이는 ```publish``` 를 나타낸다.    
해당 플래그를 통해서 로컬에 있는 포트와 내부 컨테이너의 특정 포트에 접근할 수 있는지 알려줄 수 있다.    
아래의 명령의 ```-p``` 태그의 첫 번째는 **어플리케이션에 접근하려는 로컬 포트를 지정** 합니다. 콜론(:) 다음 두 번째에는 **내부 도커 컨테이너 노출 포트를 지정**합니다.
```text
$ docker run -p 3000:3000 이미지ID
```


아래의 ```Dockerfile``` 을 통해 알 수 있는 것은 기존 이미지인 노드 이미지를 기반으로 한 커스텀 이미지가 있고, 그 안에 몇 가지의 명령들이 있다.
예를 들면 코드를 복사하고 관련 종속성들을 설치하는 것이다.
```dockerfile
FROM node

WORKDIR /app

COPY . /app

RUN npm install

EXPOSE 3000

CMD npm run start
```
그리고 ```docker build``` 명령을 통해 이미지를 만들고, ```docker run``` 명령으로 만든 이미지를 기반으로 컨테이너를 실행한다.    
만약 컨테이너를 중지하고 싶다면 ```docker ps``` 명령을 통해 실행 중인 컨테이너의 이름을 찾고, ```docker stop 컨테이너명``` 명령을 통해 중지시키면 된다.

도커 이미지를 복사해서 컨테이너를 실행시킬 때 굳이 전체 이미지 ID 를 복사할 필요는 없다. 만약 이미지 ID 가 ```abcdef``` 이고 ```abc``` 라는 중복된 이미지가 없다면 ```abc``` 를 입력해도 된다.
```text
이미지 리스트: abcdef, bcef, wewo
// 가능!
$ docker run abcdef
// 가능!
$ docker run abc
```

# 이미지는 읽기 전용!
```Dockerfile``` 의 ```COPY``` 명령을 통해 소스 코드를 이미지에 복사하고, 기본적으로 복사한 시점에서 소스 코드의 스냅샷을 만든다. 따라서 코드를 수정하더라도 이미지는 그 전의 내용들을 가진 상태이기에 변경되지 않게 된다.
- 스냅샷: 사진 찍듯이 특정 시점에 스토리지의 파일 시스템을 포착해 보관하는 기술

만약 수정 된 소스코드를 반영하기 위해서는 이미지를 다시 빌드해야 한다. 즉, 코드를 변경할 때마다 이미지를 다시 작성, 빌드해야 된다는 것이다. 하지만 코드에서 변경 사항을 선택하는 방법도 있다.   
이미지는 기본적으로 Lock 이 걸린 상태고, 빌드 후에는 수정할 수 없는 **읽기 전용**이다.    
```Dockerfile``` 의 명령들은 이미지를 생성하기 위해 실행되고, 그 후에는 잠기는 것이다.

# 이미지 Layer 이해하기
이미지를 빌드, 재빌드 할 때 변경된 부분의 명령과 그 이후의 모든 명령이 재평가 된다.    
만약 코드의 변경없이 다시 재빌드한다면 매우 빠른속도로 빌드되는 것을 확인할 수 있다.
그게 가능한 이유는 도커는 모든 명령 결과를 캐시하고 이미지를 재빌드할 때 이미지를 다시 실행할 필요가 없다면 캐시된 결과를 사용한다.
- 캐시: 자주 사용하는 데이터나 값을 미리 복사해 놓은 임시장소

그리고 이것을 레이어 기반 아키텍처라고 한다.
```Dockerfile``` 의 **모든 명령은 레이어를 나타낸다**. 이미지는 이러한 다양한 명령을 기반으로 여러 레이어에서 간단하게 구성된다.      
모든 명령들을 기반으로 하는 이미지 레이어는 레이어를 생성하고, 이러한 레이어는 캐시된다.
그리고 이미지를 기반으로 컨테이너를 실행한다면 기본적으로 ```Dockerfile``` 에 지정한 명령을 실행한 결과로 코드를 실행 중인 어플리케이션인 이미지 위에 새로운 추가 레이어를 추가한다.   
이렇게 된다면 이미지를 레이어로 실행할 때만 활성화되는 최종 레이어가 추가된다.

하나의 레이어가 변경될 때마다 다른 모든 레이어가 다시 빌드된다. 즉, 상위 레이어가 변경될 경우 모든 후속 레이어도 다시 실행된다.
```dockerfile
FROM node

WORKDIR /app

# 코드의 변경사항이 있어서 해당 레이어 시점부터 다시 빌드한다면 아래 모든 레이어도 다시 실행해야 한다 
COPY . /app

RUN npm install

EXPOSE 3000

CMD npm run start
```
도커는 다시 실행해야 하는 항목만 다시 빌드하고, 실행하여 이미지의 생성 속도를 높이기 위해 존재한다.   
하지만 이것은 코드가 변경될 때마다 ```npm install``` 명령을 반드시 실행해줘야 한다는 말이기도 하다. 원래는 ```package.json``` 파일에 변경사항이 없다면 ```npm install``` 명령도 필요가 없는 것이기 때문이다.     
이것을 해결하기 위한 방법이 있는데 그것은 ```package.json``` 파일을 먼저 복사하여 ```npm install``` 명령을 실행한 뒤, 나머지 코드를 복사하면 된다.
```dockerfile
FROM node

WORKDIR /app

COPY package.json /app 

RUN npm install

COPY . /app

EXPOSE 3000

CMD ["npm","run","start"]
```

이렇게 되면 package 종속성 관련된 것이 아닌 단순 소스파일이 변경되었을 때는 다시 ```npm install``` 명령을 실행하지 않아도 된다. 즉, ```npm install``` 의 캐시된 결과를 사용할 수 있게 된다.
따라서 결과적으로 레이어의 개념을 통해 **이미지 빌드 시간을 단축**시킬 수 있다.   

# 이미지 & 컨테이너 관리
```$ docker --help``` 명령어를 추가해서 특정 명령을 실행하거나 구성하는데 사용할 수 있는 모든 방법들을 확인할 수 있다.       

```$ docker ps``` 명령은 현재 실행 중인 모든 컨테이너를 기본적으로 리스트하여 보여준다.    
그리고 ```$ docker ps -a``` 명령은 더 이상 실행되지 않는 과거의 중지된 컨테이너를 포함하여 모든 컨테이너를 확인할 수 있다.
만약 ```$ docker ps``` 명령의 옵션들을 확인하고 싶다면 ```--help``` 명령을 추가하면 확인 가능하다.

<img width="564" alt="스크린샷 2022-05-26 오후 2 13 12" src="https://user-images.githubusercontent.com/63203480/170420676-9f69e877-f915-4f80-8ef6-837a23be6487.png">

# 컨테이너 중지 & 재시작

도커의 중요한 기능 중 하나는 중지된 컨테이너를 다시 시작할 수 있다는 것이다. 
```$ docker run``` 명령은 이미지를 기반으로 새 컨테이너를 만들고 실행하게 된다. 
만약 이미지가 변경되지 않고, 코드가 변경되지 않고, 단순히 컨테이너를 다시 실행하려면 컨테이너 리스트 중 ```NAMES``` 를 통해 ```$ docker start NAMES``` 명령을 실행시켜 재실행이 가능하다.    
하지만 ```$ docker start``` 같은 경우에는 ```$ docker run``` 명령과 다르게 실행 관련 로그 등이 뜨지 않고, 터미널에서 차단하지 않는다.   

# Attached(연결) & Detached(분리) 컨테이너 이해하기
```$ docker run``` 명령어는 기본적으로 터미널을 차단하기 때문에 타이핑은 되지만 부가적인 명령들을 실행시킬 수가 없다. 
이것을 도커에서는 강제하지 않는다. attached(연결) 모드나 detached(분리) 모드를 원하는 대로 설정할 수 있다.

```$ docker start``` 명령은 Default 가 detached 모드이고, ```$ docker run``` 은 attached 모드가 Default 이다.   
만약 어플리케이션 실행할 때마다 로그를 확인해야 한다면 detached 모드는 확인할 수 없다.

- attached 모드: 포어그라운드에서 컨테이너가 실행하는 것과 같다. 그렇기에 터미널이 차단되어 기존 터미널에서는 다른 작업을 수행하기 힘들다.
- detached 모드: 백그라운드에서 컨테이너가 실행되는 것과 같다. 기존 터미널에서 다른 작업 수행이 가능하다.

만약 ```$ docker start``` 명령을 attached 모드로 실행시키기 위해서는 ```-a``` 옵션을 추가해주면 된다. -> ```$ docker start -a NAMES```

그리고 detached 모드이기에 컨테이너 내부 상황을 추가적으로 확인하기 위한 2가지 방법이 있다.

### 1. attached 모드로 변경
만약 detached 모드로 컨테이너를 실행했어도 attached 모드로 변경할 수 있다. 
```$ docker attach NAMES``` 명령으로 가능하다.

즉, 실행 중인 컨테이너에 연결하는 것이다.

### 2. 컨테이너 로그 확인
단순히 컨테이너가 실행 중인 상태에서 로그를 확인 등의 컨테이너 내부의 정보가 필요할 때 사용한다.    
```$ docker logs NAMES``` 명령을 통해 확인할 수 있기 때문이다. 해당 명령으로 그 컨테이너에 의해 출력된 과거의 로그들을 볼 수 있다.     

또한 ```-f``` 옵션을 추가한 ```$ docker logs -f NAMES``` 명령을 통해 컨테이너에 연결된 프로세스를 다시 가져와서 향후 로그 출력 결과를 다시 보는 것이 가능하다.

# 인터렉티브 모드로 들어가기
컨테이너나 컨테이너로 실행되는 어플리케이션에는 그 어떤 것도 입력할 수 없기에 ```$ docker run``` 명령에 추가적으로 컨테이너를 인터렉티브 모드로 시작할 수 있는 ```-i, -interactive``` 옵션을 추가해야 한다.
그리고 터미널을 생성한다는 ```-t``` 옵션과 결합하면 추가적으로 무언가를 입력할 수 있게 되는 것이다. 따라서 컨테이너에서 무언가를 입력할 수 있고, 컨테이너에 의해 노출되는 터미널도 얻게 되는 것이다.    
```
$ docker run -i -t ImageID
$ docker run -it ImageId
```

- ```$ docker run``` 명령을 통해 컨테이너를 실행시키고 ```$ docker start``` 명령을 통해 재실행한다면 기존 ```run``` 시에 사용되었던 플래그들은 기억하기 때문에 ```start``` 시에도 추가적인 플래그 넣지 않아도 되는 것이다.

만약 기존 생성된 컨테이너에 인터렉티브 모드로 새로운 컨테이너를 실행하여 연결하고 싶다면 ```$ docker start``` 명령에 ```-a, -i``` 옵션을 추가하면 가능하다.   
```
$ docker start -a -i NAMES
```

이처럼 도커는 웹 서버나 웹 어플리케이션과 같이 장기적인 실행 프로세스에서만 사용되는 것이 아니라 간단한 유틸 어플리케이션에도 사용가능하다.

# 이미지 & 컨테이너 삭제하기
컨테이너를 삭제하기 위해서는 ```$ docker rm NAMES``` 명령을 사용한다. 그리고 컨테이너 삭제 시 실행 중인 컨테이너를 제거할 수 없다. 
따라서 컨테이너를 중지하고 삭제를 해야 한다.  

컨테이너를 한 번에 여러 개 삭제하기 위해서는 명령 뒤에 공백을 두고 나열하면 된다.
```
$ docker rm romantic_hawking elated_heyrovsky priceless_agnesi...
```

만약 도커 이미지 리스트를 조회하고 싶다면 ```$ docker images``` 명령을 실행하면 리스트 형태로 모든 이미지가 표시된다. 
아래의 사진처럼 하드를 차지하는 용량, 생성일자, 이미지 ID 등의 정보를 알 수 있다. 

<img width="442" alt="스크린샷 2022-05-26 오후 5 26 56" src="https://user-images.githubusercontent.com/63203480/170449747-8979e82e-f081-45bf-b85e-1a60e419d809.png">

이미지를 삭제하기 위해서는 ```$ docker rmi ImageID``` 명령을 사용한다. 이미지가 더 이상 컨테이너 사용에 실행되지 않아야 삭제가 가능하다.
따라서 기존에 존재하는 컨테이너를 먼저 삭제한 뒤에 이미지를 삭제해야 한다.     
그리고 컨테이너 삭제와 동일하게 이미지 삭제도 공백을 두고 나열하여 여러 이미지 삭제가 가능하다.
```
$ docker rmi romantic_hawking elated_heyrovsky priceless_agnesi...
```


만약 현재 존재하는 컨테이너중에서 사용되지 않는 모든 이미지를 제거할 수 있는데 바로 ```$ docker image prune``` 명령을 수행하면 된다.
여기서 주의해야 할 점은 ```images``` 가 아닌 ```image``` 라는 것이다.

# 중지된 컨테이너 자동 제거하기(유용)
```--rm``` 옵션을 통해 매번 중지된 모든 컨테이너를 수동으로 정리하지 않아도 된다. 
```
$ docker run -p 3000:3000 -d --rm ImageID 
```
위와 같이 ```--rm``` 옵션을 추가해서 컨테이너가 중지할 때마다 항상 제거되도록 만들 수 있다.    

보통 ```--rm``` 옵션은 자주 사용한다. 예를 들면 컨테이너에 서버가 포함되어 실행되고 있는 경우 코드가 변경된 경우에만 컨테이너를 중지하는 경우가 많고, 이는 결국 새로운 이미지를 빌드해서 새로운 컨테이너를 실행해야 함을 의미한다.   
따라서 수정 이전의 컨테이너는 필요가 없는 것과 같기에 제거하는 것이 타당한 시나리오다. 일반적으로 다시 시작하는 컨테이너는 아니기 때문이다.

즉, ```--rm``` 옵션을 통해서 컨테이너가 중지되었을 때 자동으로 제거할 수 있습니다.

# 작동 배경 살펴보기: 이미지 검사
이미지에는 코드와 관련 어플리케이션 환경들이 포함되어 있다. 따라서 용량을 확인해보면 꽤 큰 것을 확인할 수 있다.     
실행 중인 컨테이너는 그렇게 큰 용량을 가지지 않는다. 단순히 **명령 레이어가 이미지 위에 추가된 얇은 부가 레이어**이다.
따라서 이미지 코드는 실행 중인 컨테이너에서 사용된다. 

컨테이너는 이미지를 기반으로 빌드되고, 동일한 이미지를 기반으로 실행되는 여러 컨테이너는 이미지 내부의 코드를 공유하게 된다.
그렇기에 이미지 내부의 코드도 잠겨 있다.

만약 이미지에 대한 자세한 정보를 알기 위해서는 ```$ docker image inspect ImageId``` 명령을 통해 가능하다. 
여기서 알 수 있는 몇 가지 중요한 사항이 있다.    

이미지의 전체 ID, 생성된 날짜, 이미지를 기반으로 시작되고 실행될 컨테이너에 대한 구성이 표시된다.  
또한 어떤 운영체제인지, 이미지의 명령 레이어 등에 대한 정보도 알 수 있다.

# 컨테이너에/컨테이너로 부터 파일 복사하기
만약 실행 중인 컨테이너에 무언가를 추가하거나 컨테이너가 이미 실행 중인 상태에서 무언가를 추출하고 싶다면 어떻게 해야 할까?   
도커에는 복사를 의미하는 ```cp``` 명령이 있다. 파일 또는 폴더를 복사할 수 있다.

```
# docker cp FROM_DATA TO_DATA
$ docker cp dummy/. agitated_fermat:/test
# 로컬의 dummy 폴더를 agitated_fermat 컨테이너의 test 폴더에 복사한다. 만약 test 폴더가 없을 경우 생성한 뒤 복사한다.
```

이것이 바로 로컬과 컨테이너 간 파일을 복사하는 방법이다. 
예를 들어 컨테이너가 많은 로그 파일을 생성하는 경우 로그 파일을 컨테이너에서 로컬 호스트 시스템으로 복사할 수 있다.

만약 소스코드가 수정되었다면 원래라면 이미지를 빌드하고 컨테이너를 재시작해야 한다.   
변경한 파일을 잊어버리기 쉽기에 오류가 발생될 확률이 있고, 컨테이너에서 이상한 행동을 하거나 손상된 어플리케이션이 존재할 수 있기에 **일반적으로 사용하는 방법은 아니다.**    
따라서 파일을 컨테이너에 복사하는 것은 좋은 해결책이 아니다.


# 컨테이너와 이미지에 이름 지정 & 태그 지정하기
이미지에 태그를 지정할 수 있다. 그리고 컨테이너를 시작했을 때 자동으로 컨테이너의 이름(NAMES)이 설정되지만 이것은 잊어버리거나 입력하기 길고, 번거로울 수 있다. 
그래서 컨테이너에 고유 이름을 지정할 수 있으며, 이미지에는 고유한 태그를 추가할 수 있다.    

### 컨테이너
컨테이너를 실행할 때```--name``` 옵션을 통해 원하는 이름을 설정할 수 있다.  
```
# $ docker run ... --name TEST_NAME ImageID
$ docker run -p 3000:3000 -d --rm --name test 7a84d253398c
```
위와 같은 명령을 실행한 뒤 ```$ docker ps``` 명령을 통해 실행 중인 컨테이너를 확인해보면 test 라는 이름의 컨테이너가 실행되는 것을 확인할 수 있다.

<img width="388" alt="스크린샷 2022-05-27 오전 1 27 50" src="https://user-images.githubusercontent.com/63203480/170531925-9ebffc90-f245-48e0-9ff9-11a3dd85342b.png">

이것의 장점은 매번 리스팅해서 컨테이너의 이름을 확인할 필요가 없다는 것이다.

### 이미지
```Dockerfile``` 을 기반으로 빌드하여 이미지를 생성한다면 이것은 자동으로 생성된 ID 를 가지게 된다.   
이미지에는 이름을 지정할 수 있는데 이것을 **태그(TAG)** 라고 한다.

이미지의 태그는 2 가지로 구성된다.
1. name
2. tag

예를 들면  ```Dockerfile``` 의 ```FROM node:14(name:tag)``` 와 같이 name 을 통해 여러 개의 특정화 된 **이미지 그룹**을 만들고 tag 를 통해 이미지보다 특정화된 버전을 정의할 수 있다.    

<img width="1003" alt="스크린샷 2022-05-27 오전 1 41 32" src="https://user-images.githubusercontent.com/63203480/170534256-7bac07a9-c662-4dc3-950f-1c89cf997e74.png">

name 과 tag 를 결합하게 되면 이미지에 특정화된 버전에 대한 고유 식별자를 언제나 가지게 된다. 만약 tag 가 없다면 name 만으로 이미 고유식별자인 것이다.   

이미지를 빌드할 때 ```-t``` 옵션을 통해 ```name:tag``` 형식으로 이름을 추가할 수 있다.   
```
$ docker build -t test:latest .
```
위의 명령을 실행한 뒤 ```$ docker images``` 명령으로 이미지를 확인해보면 아래 사진처럼 REPOSITORY 에는 name 이 TAG 에는 tag 가 저장되어 있는 것을 확인할 수 있다.

<img width="144" alt="스크린샷 2022-05-27 오전 1 50 12" src="https://user-images.githubusercontent.com/63203480/170535991-a09e30cf-4789-45b0-8069-4c71f8ee72dc.png">

이렇게 name 과 tag 를 지정해서 이미지를 생성한 뒤, 컨테이너를 실행시킨다면 IMAGE_ID 를 사용하는 것이 아닌 태그를 사용할 수 있게 된다.
```
$ docker run ... test:latest(name:tag)
```
이제 이렇게 태그를 만들어준 이미지를 기반으로 컨테이너는 이름 태그 조합으로 실행이 된다.

# 이미지 공유하기
이미지가 있는 모든 사람은 그 이미지를 기반으로 컨테이너를 만들 수 있다. 
이 의미는 컨테이너를 누구와도 공유하지 않는다는 것이다. 대신 이미지를 공유한다.    
그리고 이미지를 공유하는 방법은 2가지가 있다.  
1. ```Dockerfile``` 을 공유: ```Dockerfile``` 을 기반으로 이미지를 빌드하고 컨테이너를 실행할 수 있다
2. 빌드된 전체, 완성된 이미지파일을 공유

일반적으로 팀 구성원과 공유하거나 배포를 위해서는 일반적으로 ```Dockerfile``` 이 아닌, 빌드된 이미지를 공유한다.   

# DockerHub 에 이미지 푸시(push) 하기
이미지를 푸시(=업로드)할 수 있는 2가지 위치가 있다.    
도커 허브와 개인 저장소(레지스트리)다.   

도커 허브는 공식 도커 이미지 저장소이다. 하지만 이미지를 배포하기 위해서는 개인 저장소를 더 많이 활용한다.   

도커 허브나 개인 저장소에 이미지를 푸시해서 다른 공급자나 팀원들에게 공유할 수 있습니다. 
푸시된 이미지를 사용하기 위해서는 ```$ docker pull``` 명령을 통해 받아올 수 있다.      
그리고 이미지를 push, pull 하기 위해서는 명령에 해당 공급자의 URL 이 포함되어야 한다.

로컬 설정에서 어떻게 도커 허브에 대해서 알 수 있을까?      
생성된 레파지토리가 있다면 ```도커 ID/레파지토리명```을 이미지에 지정해주면 된다.   
예를 들면 도커 허브 레파지토리의 이름이 ```durumi/docker-test``` 라고 한다면 ```durumi/docker-test``` 라는 이름의 이미지를 설정하면 되는 것이다.   

만약 새로 이미지를 빌드하려면 ```$ docker build -t durumi/docker-test .``` 명령을 통해 ```도커 ID/레파지토리명``` 형식의 이미지명을 지정해줘야 한다.   

재사용할 이미지가 있다면 이미지에 태그를 재지하는데 사용할 수 있는 명령이 있다.     
```$ docker tag``` 명령을 사용하면 된다.    
```
$ docker tag before_name new_name
```
해당 명령을 통해 새로운 이미지를 생성하는 것이 아닌 같은 ImageID 를 가진 복사 된 이미지가 만들어 진다.     

그리고 해당 이미지 ```REPOSITORY```명으로 ```$ docker push``` 명령을 실행하면 된다.
```
$ docker push durumi/docker-test
```
push 명령은 로그인 된 상태에서 가능하다. 따라서 인증 오류가 난다면 ```$ docker login``` 명령으로 로그인을 한 번만 해주면 로그인 상태가 된다.   

그리고 이미지 전체를 push 하기보다는 이미 도커 허브에 있어 의존하고 있는 이미지(ex.node, python)가 있을 경우 그 노드 이미지에 대한 연결을 설정하여 필요한 추가 코드만 푸시한다.

# 공유 이미지 가져오기(pull) & 사용하기
이미지를 도커 허브에서 다운로드 및 실행에도 사용할 수 있다.    

이미지를 다운로드하기 위해서는 ```$ docker pull``` 명령으로 가능하다.   
도커 허브 레파지토리가 Public 일 경우에는 로그인이 되지 않아도 이미지를 다운할 수 있다. 하지만 Private 일 경우 로그인 된 상태에서만 pull 이 가능하다.       
도커 허브에 이미지는 ```도커 ID/레파지토리명``` 형식이다.    

만약 도커 이미지를 다른 사람과 공유하기 위해서는 원격 이미지 풀링 및 실행에 대하여 알아야 한다.    
```$ docker pull``` 명령은 항상 컨테이너 레지스트리에서 그 이름의 최신 이미지를 가져온다.    
```$ docker run``` 은 단순히 이미지를 기반으로 컨테이너를 실행시키기도 하지만 로컬에서 이미지를 찾지 못한다면 **이미지 이름이 사용된 컨테이너 히스토리에 자동으로 접근하여 이미지를 확인**한다. 
그리고 만약 로컬에서 이미지를 찾지 못한다면 히스토리에서 찾은 이미지를 확인하여 자동으로 pulling 을 진행한다.

근데 ```$ docker run``` 명령은 그 이미지의 최신 버전이 로컬 시스템에 있는지 체크하지는 않는다. 따라서 그동안 이미지를 업데이트 하여, Docker Hub 했다면 
```$ docker run``` 명령만으로는 최신 업데이트 이미지를 제공받지 못한다.    
최신 이미지를 받기 위해서는 수동으로 ```$ docker pull``` 과 이미지 이름을 입력해 실행해야 한다.   

즉, ```$ docker run``` 명령은 로컬 시스템에 찾는 이미지가 없다면 히스토리를 검색해 자동으로 이미지를 풀링하지만 로컬 시스템이 찾는 이미지가 있다면 그것이 최신 버전인지 아닌지 상관없이 풀링하지 않고 사용한다.    
따라서 최신 버전의 이미지를 사용하기 위해서는 수동으로 풀링을 진행해야 한다.
