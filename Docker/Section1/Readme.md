# Section 1 - 시작하기
# Docker 란?
컨테이너 기술 컨테이너를 생성하고 관리하기 위한 도구이다.

### 컨테이너란 무엇이고 왜 사용해야될까요?
컨테이너는 표준화된 소프트웨어 유닛이다. 이는 코드 패키지이며 해당 코드를 실행하는데 필요한 종속과 도구가 포함되어 있다.    
예를 들면 NodeJs 런타임 환경에서 Javascript 서버를 실행시킨다면 컨테이너에는 NodeJS 런타임, 코드를 실행하는데 필요한 여러 도구들이 있을 수 있다.
즉, 컨테이너에 내가 작성한 코드를 실행하기 위해 필요한 것들을 넣는 것이다.

큰 배나 트럭에 싣는 컨테이너 비교할 수 있다. 컨테이너에는 다양한 것들을 담을 수 있지만 그 후에는 자체적으로 보관되고 격리된다.   
이처럼 도커는 소프트웨어 유닛, 코드가 포함된 패키지 및 코드를 실행하는 종속성을 보관할 수 있고 도커가 실행되는 모든 곳에서 이를 가져올 수 있다.
도커는 이러한 컨테이너를 구축하기 위한 도구이다.

# 왜 Docker 와 컨테이너인가?
### 다른 개발/ 생산 환경
우리는 종종 다른 개발/생산 환경을 가지게 된다.    
예를 들면 어떤 어플리케이션을 로컬에서 테스트했을 때는 Node 14.x 버전을 사용해서 문제 없이 코드를 실행시켰지만 다른 곳은 Node 12.x 버전을 사용해서 코드가 작동하지 않게 됩니다.    
따라서 우리가 어플리케이션을 생산할 때 동일한 개발 환경을 가지고 있는 것은 상당히 중요합니다.  
이러한 점에서 도커와 컨테이너가 도움이 됩니다. Node 의 버전을 지정할 수 있고, 이로써 **코드가 항상 정확한 버전으로 실행**되도록 할 수 있다.
어플리케이션이 **자체적으로 필요한 NodeJS 버전을 제공하는 컨테이너에서 실행**되기 때문이다.

### 팀이나 회사 내의 각각의 개발환경
관리하고 설치해야 하는 더 복잡한 종속성이 있는 더 복잡한 프로젝트가 있을 수 있다. 그리고 팀, 회사 내 모든 사람들이 같은 버전이나 환경을 사용하고 있다는 보장도 없다.
따라서 컨테이너 안에서 소스 코드가 필요로 하는 모든 것을 포함하는 환경을 보유하는 것은 큰 가치가 있다.

### 작업하고 있는 프로덕트가 여러 개 일경우 충돌하는 버전이 있을 수 있다.
예를 들면 프로젝트 A 에서는 최신 버전의 Python 을 사용하고, 또 다른 프로젝트 B 는 Python2 를 사용한다고 가정해보자.   
충돌하는 버전이 존재할 수 있으며, 이는 프로젝트 A 에서 프로젝트 B 로 전환할 때마다 버전을 제거하고 설치하는 등의 작업을 반복해야 된다.

즉, 도커와 컨테이너가 이러한 프로젝트 간의 버전을 제거하고 설치하는 등에 불필요한 작업을 해결해준다.
각각의 버전을 컨테이너에 보유하고 프로젝트별로 그들만의 컨테이너가 존재하도록 하면 된다.
컨테이너 안에 코드 실행에 필요한 모든 것이 필요하기 때문에 매번 제거, 설치 작업을 할 필요가 없다.

# 가상 머신(Virtual Machines)/OS vs Docker 컨데이너
소스 코드를 실행시키기 위한 환경적인 문제는 Virtual Machines 으로 해결할 수 있는 것이 아닌가 라는 생각을 할 수 있다.

Virtual Machines 을 사용한다는 것은 호스트 운영체제인 Windows, macOS, Linux 등이 있고 그 위에 Virtual Machines 을 설치한다는 것입니다.
즉, 컴퓨터 내부에 새로운 컴퓨터다. 완전히 새로운 가상의 컴퓨터가 생성된 것이기에 어플리케이션을 실행시키기 위해 필요한 모든 라이브러리, 종속성 및 도구 등을 설치한다.
이렇게 된다면 도커, 컨테이너와 동일한 결과를 얻을 수 있다. 모든 것이 보유된 캡슐화된 환경이기 때문이다.

![0__3QJ0gDliHRt6mMW](https://user-images.githubusercontent.com/63203480/169974301-09eb503d-6652-4e49-a21b-770bcb8e8b48.png)     
[사진 출처](https://www.google.com/url?sa=i&url=https%3A%2F%2Fmedium.com%2Fdevops-mojo%2Fdifference-between-docker-container-and-virtual-machine-comparision-between-docker-and-vm-697330d0761c&psig=AOvVaw2dcf2jddritmQl5Cg5uXBn&ust=1653463833939000&source=images&cd=vfe&ved=0CAwQjRxqFwoTCLD1jvjO9_cCFQAAAAAdAAAAABAD)

이러한 환경을 팀, 동료들과 공유하여 작업한다면 충분히 작동된다. 하지만 몇가지 문제가 존재한다.

### 문제. 여러 개의 Virtual Machine 에서 발생하는 오버헤드
하나의 컴퓨터에서 매번 새로운 컴퓨터를 내부에 설치해야 하고, 이 떄문에 메모리, CPU, 하드 공간을 낭비하게 된다.
이렇게 계속해서 Virtual Machine 이 많아진다면 문제가 될 것이다.    
항상 동일하게 복제되는 많은 것들이 존재한다. 특히 OS 가 그렇다. 모든 Virtual Machine 에서 리눅스를 사용한다고 해도 여전히 Virtual Machine 들에는 별도로 설치되어 있습니다.   
그리고 당연히 많은 공간을 낭비하게 됩니다.

### Virtual Machines 의 장점
1. 분리된 환경을 생성할 수 있다.
2. 환경별 구성을 가질 수 있다.
3. 모든 것을 안정적으로 공유하고 재생산할 수 있다.

### Virtual Machines 의 단점
1. 중복 복제 등 낭비되는 공간이 발생된다.
2. 호스트 시스템 위에 추가 시스템이 실행되기 때문에 성능이 나빠질 수 있다. 실제로 여러 개일 경우 성능은 저하됩니다.
3. 재생산 및 공유가 가능하더라도 원하는 모든 시스템에 Virtual Machine 을 설정해야 하고 정확히 동일한 방식으로 구성해야 하기 때문에 까다로울 수 있다.

즉, Virtual Machine 을 통해 문제를 해결할 수 있지만 완벽한 방법은 아니다. 이것이 도커와 컨테이너를 사용하는 이유이다.

컨테이너가 핵심인데 도커는 이를 만들과 관리하기 위한 도구일 뿐이다.

### Docker 컨테이너가 Virtual Machine 보다 더 나은 이유는 뭘까?
컨테이너를 사용한다면 여전히 호스트 운영 체제인 Windows, macOS, Linux 가 존재하지만 하나의 머신에 몇 대의 추가적인 머신을 설치하지는 않는다.
그 대신, 운영 체제가 기본적으로 내재하고 있거나 컨테이너 에뮬레이트를 지원하는 내장 컨테이너를 활용한다. 도커는 이것이 작동하도록 처리한다.

- 에뮬레이터: 다른 컴퓨터 또는 프로그램을 모방하는 컴퓨터나 프로그램

그리고 그 위에 도커 엔진이라는 툴을 실행한다. 그리고 여러 개의 컨테이너로 분리한다.   
이러한 컨테이너에는 소스 코드와 NodeJS 와 같이 코드에 필요한 중요한 툴 및 런타임이 포함되어 있지만 **여러 개의 운영체제들이나, 수많은 툴이나 비슷한 것을 포함하지 않는다.**    
컨테이너 내부에 작은 운영체제 계층이 있을 순 있지만 Virtual Machine 에 설치하는 것보다 훨씬 작고 가벼운 버전이다.

컨테이너의 더 좋은 이유는 Config 파일을 통해서 컨테이너를 구성하고 이를 설명할 수 있기 때문이다. 또한 이를 공유함으로써 다른 사람들이 컨테이너를 다시 만들 수 있도록 하거나
**컨테이너 이미지를 빌드**할 수도 있다. 그 이미지를 통해 모든 사람이 개인의 시스템에 있는 동일한 컨테이너를 시작할 수 있도록 할 수 있다.

#### Docker Container
1. 운영체제와 시스템에 미치는 영향이 적고, 매우 빠른 속도를 제공한다. 최소한의 디스크 공간을 사용한다.
2. 이미지와 Config 파일이 있기에 공유, 재구축 및 배포하는 것이 매우 쉽다.
3. 어플리케이션에 맞는 환경을 보유하지만 쓸데없는 부가적인 것이 없다.

#### Virtual Machines
1. 운영체제에 많은 영향을 미치고, 속도가 느리며, 디스크 공간을 더 많이 차지한다.
2. 공유, 재구축 및 배포 모두 수행할 순 있지만 Docker Container 보다 까다로울 것이다.
3. 환경을 캡슐화 하지만 어플리케이션을 실행하는데 필요한 것들만 캡슐화하는 것이 아니라 컴퓨터 전체를 캡슐화 한다.

# Docker Setup
### Mac, Windows
Docker Desktop 을 설치해야 한다(**권장**). 만약 Docker Desktop 을 설치할 환경이 아니라면 Docker Toolbox 를 이용해야 한다.   
Docker Desktop 과 Docker Toolbox 은 단순히 도커를 간편하게 활용할 수 있는 도구일 뿐이다.

### Linux
Linux 일 경우에는 도커가 사용하는 기술과 컨테이너를 기본적으로 지원한다.

# Docker 실전 참여하기
Docker 의 컨테이너는 항상 이미지를 기반으로 하기 때문에 먼저 이미지라는 것을 생성해야 한다.   
이미지를 생성하기 위해 확장자 없는 ```Dockerfile``` 을 만들어줘야 한다.
그리고 Dockerfile 에서 최종적으로 **컨테이너를 설정하는 방법을 설명**한다.

### NestJS Base Dockerfile
```dockerfile
FROM node:16-alpine

WORKDIR /app

COPY package.json .

RUN npm install

COPY . .

RUN npm run build

# 해당 이미지는 3000 포트에 공개될 예정이라는 것을 명시
EXPOSE 3000

# ["npm","run","start:prod"] === npm run start:prod
CMD ["npm","run","start:prod"]
```
위와 같이 Dockerfile 을 만든 뒤 ```docker build .``` 명령어를 입력하면 이미지가 만들어진다.

<img width="657" alt="스크린샷 2022-05-24 오후 9 31 14" src="https://user-images.githubusercontent.com/63203480/170035751-172029c7-99e8-4718-80c5-06b37c606424.png">

그다음에 ```docker run -p 3000:3000 이미지파일``` 명령어를 통해 빌드한 이미지를 기반으로 컨테이너를 실행할 수 있다.
```-p``` 옵션을 통해 호스트 운영체제와 컨테이너 환경의 포트를 매핑시킨다. 왜냐하면 컨테이너와 호스트 운영 체제 사이에는 기본적인(Default) 연결이 없기 때문이다.    
예를 들어 컨테이너에서 실행 중인 어플리케이션에 HTTP 요청을 보내려면 통신하려는 컨테이너의 포트를 열어야 합니다. 그렇지 않다면 컨테이너에 잠긴 네트워크이므로 외부에서 연결할 수 없게 된다.

그리고 현재 실행중인 컨테이너를 확인하고 싶다면 ```docker ps``` 명령어를 통해 알 수 있다.

<img width="903" alt="스크린샷 2022-05-24 오후 9 49 57" src="https://user-images.githubusercontent.com/63203480/170038661-730a6c57-2f85-4140-bc88-df720655adb0.png">

또한 실행중인 도커 컨테이너와 서버를 중지하고 싶다면 ```docker stop NAMES``` 명령어를 통해 가능하다.
```NAMES``` 는 ```docker ps``` 명령어 실행시 나오는 것이다. ```docker ps``` 명령은 현재 실행중인 프로세스를 보여준다.

위의 예제를 통해 컨테이너화된 어플리케이션을 생성했다. 모든 패키지 관련 종속성을 설치하기 위해서 프로젝트 디렉토리 안에서 ```npm install``` 을 실행하지 않아도 웹 서버를 실행시킬 수 있다.    
이 모든 것이 도커 덕분에 가능한 것이다.
