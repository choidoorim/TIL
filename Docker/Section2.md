# Section2 - 이미지 & 컨테이너: 코어 빌딩 블록
# 이미지와 컨테이너 - 무엇이며, 왜 사용할까?
컨테이너는 어플리케이션, 웹 사이트, 노드 서버, 실행 환경 등 어떤 것이든 포함하는 작은 패키지다.   

이미지는 컨테이너를 위한 템플릿, 블루프린트(노드를 연결하여 프로그램의 논리를 표현) 이다. 이미지는 실제로 코드와 코드를 실행하는데 필요한 도구를 포함한다. 그 다음 컨테이너가 실행되어 코드를 실행한다.    
즉, 이미지는 모든 설정관련 명령어와 모든 코드가 포함된 **공유 가능한 패키지**다.   
그리고 컨테이너는 이러한 **이미지의 구체적인 실행 인스턴스**다.

<img width="969" alt="스크린샷 2022-05-25 오전 11 58 38" src="https://user-images.githubusercontent.com/63203480/170170542-aa29f792-4d4a-4392-b674-95f90aa81414.png">

이미지를 기반으로 하는 컨테이너를 실행시키는 것이 기본적인 도커의 개념이며 모든 것이라고 볼 수 있다.

# 외부 이미지의 사용 및 실행
컨테이너를 실행할 수 있도록 이미지를 생성하고 가져오는 방법이 있다.

### 1. 이미 존재하는 이미지를 사용한다.
기본적으로 팀 또는 개인이 구축해놓은 이미지를 사용할 수 있다. 그리고 그 이미지를 기반으로 컨테이너를 생성할 수 있다.    
예를 들면 Docker Hub 에 있는 ```node``` 이미지를 사용할 수 있다.    
```docker run node```

기본적으로 컨테이너는 주변 환경과 격리되어 있기에 노드를 이미지로 실행하거나 노드 이미지를 기반으로 하는 컨테이너로 실행했어도 이것만으로는 별 의미가 없다.     
노드 기반 컨테이너를 실행하고 사용하기 위해서는 노드 명령어를 실행할 수 있는 인터렉티브 노드 터미널에 들어가야 한다.    
```docker run -it node```   

이미지는 컨테이너에 필요한 모든 논리와 모든 코드를 보관하는데 사용하는 것이며, ```run``` 명령어를 사용해서 이미지의 인스턴스를 만든다.
그리고 이것은 이미지를 기반으로 하는 구체적인 컨테이너를 생성한다. 

### 2. 자신만의 커스텀 이미지를 만든다.
일반적으로 공식 베이스 이미지를 가져온 다음 그 위에 코드를 추가하여 그 이미지로 코드를 실행한다.

# Dockerfile 을 사용하여 자체 이미지 빌드하기
```Dockerfile``` 이라는 파일명은 도커에 의해서 식별되는 이름입니다.   
이 파일에서는 자체 이미지를 빌드할 때 실행하려는 도커에 대한 명령들이 포함된다.

일반적으로는 ```FROM``` 명령으로 시작한다. 이를 통해서 다른 기본 이미지에 우리의 이미지를 구축할 수 있게 된다.   
이름에는 내 시스템에 존재하거나 도커 허브 상의 이미지명을 넣는다.    
```dockerfile
# node - 도커 허브 이미지, node 라는 이름의 이미지가 존재하기에 가능
# 도커에게 노드 이미지를 가지고 오는 것으로 시작한다라고 말하는 것
FROM node
```
만약 node 이미지를 기반으로 컨테이너를 실행했다면 이 이미지가 로컬에 다운로드 및 캐시되었기 때문에 실제로 해당 이미지를 기반으로 컨테이너를 실행하는 순간 로컬에도 존재하게 된다.   

그 다음 단계로 도커에게 로컬 머신에 있는 어떤 파일이 이미지에 들어가야 하는지 알려야 한다.
이것은 ```COPY``` 명령을 사용한다. 매우 간단한 명령으로는 ```COPY . .``` 이다.    
COPY 는 2가지의 경로를 지정합니다.    
1. 컨테이너의 외부, 이미지의 외부 경로이며 이미지로 복사되어야 할 파일들이 있는 곳이다. 컨테이너 또한 이미지는 환경과 코드를 갖고 있고 거기서 실행되는 것을 기억하자.
    - 만약 ```.``` 일 경우 도커에게 기본적으로 Dockerfile 이 포함된 동일한 폴더임을 알리는 것이다. 즉, 이 프로젝트의 모든 폴더, 하위 폴더 및 파일을 복사해야 한다고 도커에게 알리는 것이다.
2. 첫번째에 복사해야할 파일들을 저장하는 이미지 내부의 경로이다.
    - 모든 이미지와 이미지를 기반으로 생성된 모든 컨테이너에는 로컬 파일시스템에서 완전히 분리된 자체 내부 파일 시스템이 있다. 이것은 도커 컨테이너 내부에 숨겨져 있다.
    - 만약 ```COPY . /app``` 으로 한다면 로컬에 파일들이 컨테이너 내부의 app 폴더에 복사되는 것이다. 만약 폴더가 없을 경우에는 이미지와 컨테이너에 생성된다.
```dockerfile
FROM node

COPY . /app
```

노드같은 경우에는 모든 종속성들을 설치하기 위해 ```npm install``` 을 실행했어야 되기 때문에 이미지에 명령어 ```RUN``` 하고 싶다고 알릴 수 있다.
```dockerfile
FROM node

COPY . /app

RUN npm install
```
기본적으로 이러한 모든 명령은 도커 컨테이너 및 이미지의 작업 디렉토리에서 실행된다.

도커에게 모든 명령 실행과정은 어떤 디렉토리에서 진행해야 한다고 알려줄 수 있는 방법이 있다. 바로 ```WORKDIR``` 명령을 사용하면 된다.   
이것은 도커 컨테이너의 작업 디렉토리를 설정하는 명령이다. 
```dockerfile
FROM node

WORKDIR /app

COPY . /app

RUN npm install
```
이렇게 지정한다면 후속 명령어들이 모두 ```/app``` 이라는 작업 디렉토리에서 실행된다는 것이 된다.   
그리고 작업 디렉토리를 ```/app``` 으로 설정했다는 사실을 감안해서 로컬에 파일이 복사되는 경로를 ```./``` 으로 변경할 수 있다. ```./``` 은 도커 컨테이너의 현재 작업 디렉토리를 의미한다.
```dockerfile
FROM node

WORKDIR /app

COPY . ./
# COPY . /app - 절대 경로를 지정해줘도 상관없다
# 절대경로로 명시하여 파일을 복사할 위치를 명확히 알 수 있게되고 현재 작업 디렉토리가 무엇인지 명확하여 더 좋을 수 있다.

RUN npm install
```

마지막으로 설정이 끝났다면 어플리케이션을 실행시키는 명령어를 실행해야 한다.
```RUN``` 명령어는 이미지가 빌드될 때마다 실행되는 것이기에 올바르지 않다.   
컨테이너를 시작하는 경우에만 서버를 시작하고 싶은 것이기에 ```CMD``` 명령을 사용하면 된다.
```RUN``` 명령어와 차이가 있다면 ```CMD``` 는 이미지가 생성될 때 실행되는 것이 아닌 **이미지를 기반으로 컨테이너가 시작**될 때 실행된다.    
```dockerfile
FROM node

WORKDIR /app

COPY . ./app

RUN npm install

CMD npm run start
```

만약 노드 웹서버가 3000 포트에서 수신 대기하고 있다고 가정해보자. 컨테이너 내부의 노드 어플리케이션에서 3000 포트를 수신할 때, 컨테이너는 그 포트를 우리의 로컬에 노출하지는 않는다.   
따라서 컨테이너 내부에서만 무언가를 수신 대기 중이기에 3000 포트에서 수신이 불가능하다.  
그래서 언제나 Dockerfile 의 마지막 명령 전에 우리의 로컬 시스템에 특정 포트를 노출하고 싶다는 것을 도커에게 알리는 ```EXPOSE``` 명령을 사용해야 한다.   
```dockerfile
FROM node

WORKDIR /app

COPY . ./app

RUN npm install

EXPOSE 3000

CMD npm run start
```

# 자체 이미지를 기반으로 컨테이너 실행하기
자체 커스텀 이미지를 만들기 위해서는 ```docker build``` 명령을 통해 실행한다.   
```docker build``` 명령 다음 문구에 ```Dockerfile``` 이 어디에 있는지 알려줘야 한다.    
예를 들면 아래의 명령은 현재 실행하려는 빌드 명령기준 현재 디렉토리 위치에 도커파일이 있다는 뜻입니다.
```text
$ docker build .
```
빌드된 이미지 ID와 ```docker run 이미지ID```명령을 사용해서 컨테이너를 실행시킬 수 있습니다.

컨테이너를 실행 시키면 서버를 실행시키는 것과 같다. 하지만 Dockerfile 에 포트를 노출했음에도 불구하고 접속이 되지 않는다. 그 이유는, Dockerfile 에는 ```EXPOSE``` 명령을 통해 포트를 노출시켰지만 사실 이 명령은 documentation 목적으로만 추가되었기 때문이다. 
즉, ```Dockerfile``` 을 통해 ```EXPOSE``` 명령을 통해 포트를 노출해도 아무 것도 하지 않는 것이다. 따라서 ```EXPOSE``` 명령은 필수가 아닌 선택 사항이다.
하지만 일반적으로는 ```EXPOSE``` 명령을 통해 문서화 하는 것이 모범적인 사례이다.      
위의 문제를 해결하기 위해서는 ```docker run``` 명령을 수행할 때 ```-p``` 플래그를 추가해줘야 한다. 이는 ```publish``` 를 나타낸다.    
해당 플래그를 통해서 로컬에 있는 포트와 내부 컨테이너의 특정 포트에 접근할 수 있는지 알려줄 수 있다.    
아래의 명령의 ```-p``` 태그의 첫 번째는 **어플리케이션에 접근하려는 로컬 포트를 지정** 합니다. 콜론(:) 다음 두 번째에는 **내부 도커 컨테이너 노출 포트를 지정**합니다.
```text
$ docker run -p 3000:3000 이미지ID
```


아래의 ```Dockerfile``` 을 통해 알 수 있는 것은 기존 이미지인 노드 이미지를 기반으로 한 커스텀 이미지가 있고, 그 안에 몇 가지의 명령들이 있다.
예를 들면 코드를 복사하고 관련 종속성들을 설치하는 것이다.
```dockerfile
FROM node

WORKDIR /app

COPY . ./app

RUN npm install

EXPOSE 3000

CMD npm run start
```
그리고 ```docker build``` 명령을 통해 이미지를 만들고, ```docker run``` 명령으로 만든 이미지를 기반으로 컨테이너를 실행한다.    
만약 컨테이너를 중지하고 싶다면 ```docker ps``` 명령을 통해 실행 중인 컨테이너의 이름을 찾고, ```docker stop 컨테이너명``` 명령을 통해 중지시키면 된다.    

도커 이미지를 복사해서 컨테이너를 실행시킬 때 굳이 전체 이미지 ID 를 복사할 필요는 없다. 만약 이미지 ID 가 ```abcdef``` 이고 ```abc``` 라는 중복된 이미지가 없다면 ```abc``` 를 입력해도 된다.   
```text
이미지 리스트: abcdef, bcef, wewo
// 가능!
$ docker run abcdef
// 가능!
$ docker run abc
```

# 이미지는 읽기 전용!
```Dockerfile``` 의 ```COPY``` 명령을 통해 소스 코드를 이미지에 복사하고, 기본적으로 복사한 시점에서 소스 코드의 스냅샷을 만든다. 따라서 코드를 수정하더라도 이미지는 그 전의 내용들을 가진 상태이기에 변경되지 않게 된다.
- 스냅샷: 사진 찍듯이 특정 시점에 스토리지의 파일 시스템을 포착해 보관하는 기술   

만약 수정 된 소스코드를 반영하기 위해서는 이미지를 다시 빌드해야 한다. 즉, 코드를 변경할 때마다 이미지를 다시 작성, 빌드해야 된다는 것이다. 하지만 코드에서 변경 사항을 선택하는 방법도 있다.   
이미지는 기본적으로 Lock 이 걸린 상태고, 빌드 후에는 수정할 수 없는 **읽기 전용**이다.    
```Dockerfile``` 의 명령들은 이미지를 생성하기 위해 실행되고, 그 후에는 잠기는 것이다. 
