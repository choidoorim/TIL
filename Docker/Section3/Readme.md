# 데이터 카테고리/다양한 종류의 데이터 이해하기
### 어플리케이션이 실행되는 동안 생성된 임시 데이터
예를 들어 웹 사이트의 경우 사용자가 입력폼에 무언가를 입력할 수 있고 그런 다음 우리는 그 데이터를 가져와 서버에서 실행 중인 컨테이너에서 처리하는데 
이때 입력된 그 사용자 데이터가 임시 데이터이다.    
코드의 변수에 저장될 수 있기에 결국 메모리에만 저장되거나, 데이터베이스나 파일에 저장될 수도 있다.    
임시 데이터는 읽기와 쓰기가 가능하기에 이미지가 아닌 컨테이너에 저장된다.     

<img width="1059" alt="스크린샷 2022-05-30 오후 1 11 33" src="https://user-images.githubusercontent.com/63203480/170915743-63fb047f-cc3f-4dd6-9366-b9b9843a94c7.png">

이미지 위에 도커에 추가된 컨테이너 레이어는 기본적으로 로직이라 할 수 있는데, 이미지와 이미지의 파일시스템을 인식하고, 복사하지 않고 파일 시스템을 미러링하는 로직이다.    
도커는 실제로 read-write 액세스 권한을 가지며 파일 시스템을 조작할 수 있다. 이미지에서 변경하지 않으며, 컨테이너 레이어에서 변경한다.   
도커는 컨테이너의 변경 사항을 추적하고, 이미지의 파일 시스템을 가져와서 최종 파일 시스템을 파싱해서 Read-Write 레이어에 저장된 변경 사항과 결합시킨다.    

컨테이너에게 정보를 저장하라고 하면, 저장하고 파일이 무엇이든 간에 이 Read-Write 레이어에 저장하거나 그 Read-Write 레이어의 도움을 받아 저장한다.    
이러한 저장된 정보들은 컨테이너에만 있지 로컬 파일 시스템, 로컬 머신에 없고, 이미지에도 없다.

### 영구 어플리케이션 데이터
일반적인 어플리케이션은 사용자의 데이터를 받아 파일에 저장하거나, 일반적인 데이터베이스에 저장한다. 그리고 그 데이터는 지속되어야 합니다.    
실행중인 컨테이너에서는 그 데이터를 가져와 생성한다. 따라서 컨테이너에서 실행 중인 어플리케이션 내의 데이터는 저장되어야만 한다.
왜냐하면 컨테이너가 중지되거나 재실행되어도 데이터는 그대로 있어야 하기 때문이다. 또한 컨테이너가 삭제되어도 데이터는 보존되어야 한다.   

새로운 버전의 어플리케이션을 배포하게 된다면 어쨌든 컨테이너를 중지시키고 새 버전을 배포하게 된다. 하지만 그 과정에서 어플리케이션 데이터가 손실되서는 안된다.   
컨테이너를 중지하게 되면 임시 데이터, 영구 데이터 등 손실되지 않아야 하는 데이터가 존재한다.   
따라서 데이터를 컨테이너에 저장하지만 **볼륨의 도움**을 받게 된다.

볼륨은 도커에 적용된 핵심적인 개념중 하나이다. 

# 데모 앱 구축 & 이해하기
```Dockerfile``` 에서 우리 로컬 폴더를 이미지에 복사하고 컨테이너는 그 이미지를 기반으로 실행되기 때문에 실행 중인 어플리케이션에 파일을 저장한다고 해도 로컬에는 저장되지 않는다.    
이것을 통해 알 수 있는 것은 로컬 폴더를 기반으로 하는 자체 파일 시스템이 있다는 것을 의미한다. 하지만 복사 된 이후에는 로컬과 실행 중인 이미지 내부 파일 시스템 사이에 연결은 없다.

# 문제 이해하기
컨테이너를 중지하고 재실행한다면 기존 존재하던 컨테이너의 파일이 손실되지 않는다. 하지만 컨테이너를 삭제한다면 기존 컨테이너에서 생성되어 저장된 모든 데이터는 손실되게 된다.   
컨테이너는 파일을 생성할 때, 이미지에 쓰지 않고 컨테이너 레이어에 저장한다.  

즉, 동일한 이미지에 기반한 다수의 컨테이너가 서로에게 완전히 격리된다는 것이 바로 도커의 핵심 개념이다.

그렇다면 위와 같이 데이터가 손실되는 것을 해결할 수 있는 방법은 무엇일까? 그것은 바로 **볼륨**이라는 도커 내장 기능이다.

# 볼륨
볼륨은 데이터를 유지하는 것을 도우며 데이터의 손실을 해결하는데 도움이 된다.   

볼륨은 호스트 머신의 폴더이다. 컨테이너나 이미지에 있는 것이 아니다.  
호스트 컴퓨터에 장착된 하드 드라이브에 존재하여 사용가능하거나, 컨테이너로 매칭되는 것을 의미한다.   
즉, 볼륨은 도커가 인식하는 호스트 머신인 로컬 컴퓨터에 있는 폴더로 도커 컨테이너 내부의 폴더에 매핑된다.   

볼륨은 컨테이너 내부의 폴더와 호스트 머신 상의 컨테이너 외부 폴더에 연결할 수 있다. 그리고 두 폴더의 변경 사항은 다른 폴더에 반영된다.
따라서 호스트 머신에 파일을 추가하면 컨테이너 내부에서 접근할 수 있고, 컨테이너가 매핑된 경로에 파일을 추가하면 컨테이너 외부, 즉 호스트 머신에서도 사용할 수 있다.

볼륨은 컨테이너가 종료된 경우에도 지속되며 계속 존재한다. 컨테이너에 볼륨을 추가하는 경우 해당 볼륨은 제거되지 않으며 컨테이너가 제거되어도 해당 볼륨이 유지되므로 데이터가 유지된다.
그리고 컨테이너는 볼륨에 데이터를 읽고 쓸 수 있다. 컨테이너 외부에서 액세스하려는 폴더 또는 단순히 컨테이너 종료 및 컨테이너 제거 후에도 생존해야하는 데이터에 사용할 수 있다.

# 볼륨을 컨테이너에 추가 
볼륨을 사용하기 위한 첫 번째 방법은 ```Dockerfile``` 에서 ```VOLUME``` 명령을 추가하는 것이다.   
컨테이너의 외부 폴더에 매칭되어질 내 컨테이너 내부 위치를 지정해줘야 한다. 즉, 데이터가 생존할 위치를 지정하는 것이다.
```dockerfile
WORKDIR /app
#...
VOLUME ['/app/feedback']
#...
```
볼륨의 이름을 지정하지 않는다면 이미지나 컨테이너와 같이 자동으로 도커에서 지정해준다.

# Named 볼륨으로 구조하기!
도커에는 실제로 여러 가지의 외부 데이터 저장 매커니즘이 있다. 그것은 **볼륨과 바인드 마운트** 이다.   
실제로는 두 가지 타입(Anonymous/Named Volumes)의 볼륨이 있고, 둘 다 고유한 목적과 사용예가 있다.   

도커 파일의 ```VOLUME ['/app/feedback']``` 명령은 해당 이미지에 익명의(Anonymous) 볼륨을 추가하고 그 이미지를 기반으로 실행되는 컨테이너에 데이터를 추가한다. 

### 익명의 볼륨
```docker volume ls``` 명령을 통해 도커가 현재 관리 중인 모든 볼륨을 리스팅한다. 
익명의 볼륨일 경우 **컨테이너가 중지되었을 때, 해당하는 익명 볼륨이 리스트에서 조회되지 않는다**.    
즉, 익명 볼륨은 컨테이너가 존재하는 동안에만 실제로 존재한다는 것이다.

컨테이너에 정의된 경로는 생성된 어떤 볼륨에 매핑된다. 그래서 호스트 머신 상의 생성된 경로로 연결된다.    
예를 들어 ```Dockerfile``` 의 ```VOLUME ['/app/feedback']``` 경로는 호스트 머신의 어떤 폴더에 매핑된다. 
하지만 우리는 그 경로를 알지 못한다. 왜냐하면 도커에서 관리하기 때문이다. 우리의 컴퓨터에 존재하며, 우리가 접근할 수 없도록 되어있다.

만약 컨테이너가 중지되었을 때 볼륨만 삭제되지 않는다면 이론적으로 좋은 개념이다. 이것은 Named 볼륨을 사용하면 컨테이너가 종료된 후에도 볼륨이 유지될 수 있다. 
즉, 하드 드라이브의 폴더가 그대로 유지된다. 따라서 그 이후에 새 컨테이너를 시작하면 볼륨과 폴더가 복구되어 해당 폴더에 저장된 모든 데이터를 계속 사용할 수 있다.

### 명명(Named) 볼륨
따라서 Named 볼륨은 영구적이어야 하는 데이터나, 편집하거나 직접 볼 필요가 없는 중요한 데이터에 적합하다.   

도커 파일 내부에는 Named 볼륨을 생성할 수 없다. 대신 **컨테이너를 실행할 때, 명령을 추가해서 Named 볼륨을 생성**해야 한다.  
```
// ex) $ docker run -v [원하는 이름]:[컨테이너 파일 시스템 내부 경로]
$ docker run -v feedback:/app/feedback
```
컨테이너 내부의 ```/app/feedback``` 폴더에 연결하지만 해당 볼륨은 우리가 선택한 ```feedback``` 이름으로 저장된다.   
Named 볼륨은 컨테이너가 종료될 때 도커에 의해서 삭제되지 않는다는 것이다. 또한 Named 볼륨은 하나의 컨테이너에만 연결되지는 않는다. 

만약 사용하지 않는 볼륨이 있을 경우 ```$ docker volume rm VOL_NAME``` 또는 ```$ docker volume prune``` 명령을 통해 볼륨을 삭제할 수 있다.    
익명 볼륨은 ```Dockerfile``` 에서 지정해주고, Named 볼륨은 명령을 통해 지정하는 것이다.

## 바인드 마운트(Bind Mounts)
우리가 어플리케이션의 소스코드를 수정했을 때, 이미지를 다시 빌드하지 않는 한 이러한 변경 사항은 실행 중인 컨테이너에 반영되지 않는다.
하지만 어플리케이션이 실행되고 있는 중에 도커를 사용한다면 이러한 변경 사항이 반영되는 것은 매우 중요하다. 
그렇지 않다면 변경사항이 있을 때마다 매번 전체 이미지를 리빌드하고 컨테이너를 재실행하여 하기 때문이다.    
이러한 점을 바로 **바인드 마운트**가 도와준다. 

호스트 머신의 파일 시스템 상의 볼륨이 어디에 있는지 우리가 알 수 있는 방법이 없다. 하지만 바인트 마운트의 경우 볼륨의 위치를 알고 있다.     
Named 볼륨은 영구 데이터에 도움이 되지만, 편집이 불가능하다. 왜냐하면 호스트 머신의 어디에 저장되어 있는지 모르기 때문이다.   

바인드 마운트를 추가하기 위해서는 Dockerfile 내부에서 하는 것이 아니다.
실제로 이미지가 아니라 실행하는 컨테이너에만 적용되기 때문에 이미지에는 영향을 주지않고 컨테이너에만 영향을 준다.

바인드 마운트는 컨테이너를 실행할 때 ```-v``` 옵션을 통해 추가한다.     
```
//ex) $ docker -v [현재 프로젝트 절대경로]:[컨테이너 앱 경로] ...
$ docker run -d -p 3000:80 --rm --name feedback-app -v feedback:/app/feedback -v /Users/choidoorim/Desktop/Docker 강의/Source/data-volumes-02-added-dockerfile:/app feedback-node:volume      
```

경로에 특수 문자나 공백이 포함된 경우 깨지지 않도록 ```"``` 콜론을 추가해줘도 된다.
```
"/Users/choidoorim/Desktop/Docker 강의/Source/data-volumes-02-added-dockerfile:/app"
```

바인딩 마운트로 **공유 중인 폴더에 도커가 액세스할 수 있는지 반드시 확인**해야 한다.
도커의 ```Preferences(기본설정) -> Resources -> FILE SHARING``` 에서 공유 중인 폴더의 상위 폴더가 표시되어야 한다.

<img width="850" alt="스크린샷 2022-06-03 오후 9 35 26" src="https://user-images.githubusercontent.com/63203480/171854836-6cfc9d17-ed15-44aa-9c77-4b7ec6f13207.png">

만약 없다면 공유 가능 리소스로 추가하는 것이 중요하다.

## 다른 볼륨 결합 & 병합
