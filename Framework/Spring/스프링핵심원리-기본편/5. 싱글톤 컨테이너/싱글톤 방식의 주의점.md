싱글톤 객체는 여러 클라이언트가 하의 같은 객체 인스턴스를 공유하기 때문에 상태를 유지(stateful) 하기 설계하면 안된다. 즉, 무상태로 설계해야 한다.      
무상태란 특정 클라이언트에 의존적인 필드가 있으면 안된다. 그리고 값을 변경할 수 있는 필드가 있으면 안된다. 가급적 읽기만 가능해야 하고, 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.     
스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수도 있다.

```java
public class StatefulService {  
    private int price;  
  
    public void order(String name, int price) {  
        System.out.println("name  = " + name + " price = " + price);  
        this.price = price; // 이 부분이 문제가 발생한다  
    }  
  
    public int getPrice() {  
        return price;  
    }  
}
```

```java
class StatefulServiceTest {  
    @Test  
    void statefulServiceSingleton() {  
        ApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class);  
        StatefulService statefulService1 = ac.getBean(StatefulService.class);  
        StatefulService statefulService2 = ac.getBean(StatefulService.class);  
  
        // Thread A: A 사용자가 10000원을 주문  
        statefulService1.order("userA", 10000);  
        // Thread B: B 사용자가 10000원을 주문  
        statefulService2.order("userB", 20000);  
  
        // Thread A: A 사용자 주문 금액 조회  
        int price = statefulService1.getPrice();  
        System.out.println("price = " + price);
        Assertions.assertThat(price).isEqualTo(10000); // fail
    }  
  
    static class TestConfig {  
        @Bean  
        public StatefulService statefulService() {  
            return new StatefulService();  
        }  
    }  
}
```

기본적으로 클라이언트에서 요청이 오면 새로운 스레드가 할당이 된다.      
위의 코드에서 우리가 생각한대로라면 사용자 A 의 주문을 조회했을 때 10000 이라는 결과가 출력되야 한다.
하지만 결과는 20000 원이다. 왜냐하면 statefulService1 과 statefulService2 는 같은 인스턴스를 사용하고 있기 때문이다.     
만약 실제 상황이였다면 사용자 A 가 10000원을 결제해서 주문을 했는데 20000원이 주문이 된 것이기에 매우 큰 문제가 발생한 것이다.     
따라서 공유 필드는 반드시 조심해야 한다! 스프링 빈은 **항상 무상태로 설계**해야 한다.

