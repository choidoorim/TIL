지금까지 코드는 구현체가 직접 어떤 구현체를 선택해서 사용할 지를 직접 지정해서 구현하고 있었다.
구현체는 자신의 기능 구현과 어떤 것을 사용해야 할지 등 다양한 책임을 가지고 있는 것이다.

```java
public class OrderServiceImpl implements OrderService {
	private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
```

따라서 관심사를 분리해야 한다.

## AppConfig 등장
AppConfig 는 어플리케이션의 전체동작 방식을 구성하기 위해, 구현 객체를 생성하고, 연결하는 책임을 가지는 별도의 설정 클래스이다.

어떤 구현체가 들어갈지에 대한 것은 생성자를 통해 선택하는 것이다.

```java
// AppConfig
public class AppConfig {  
    public MemberService memberService() {  
        return new MemberServiceImpl(new MemoryMemberRepository());  
    }  
}

public class MemberServiceImpl implements MemberService {  
    private final MemberRepository memberRepository;  
  
    public MemberServiceImpl(MemberRepository memberRepository) {  
        this.memberRepository = memberRepository;  
    }
```

위의 코드는 DIP 를 지키게 되는 것이다. MemberServiceImpl 클래스는 구체화된 클래스에 대해서는 전혀 알 수 없고 인터페이스에만 의존하기 있기 때문입니다. 
객체에 대한 의존관계를 AppConfig 라는 곳에서 생성해서 넣어준 것이다.

따라서 **객체가 생성자를 통해 주입되기 때문에 생성자 주입**이라고 한다.
그리고 변수에 **final 이 설정되어 있다면 반드시 생성자를 통해 값을 할당**받을 수 있다.

AppConfig 클래스는 어플리케이션의 실제 동작에 필요한 **구현 객체를 생성하고 연결** 한다.    
그리고 생성한 객체 인스턴스의 참조(Reference) 값을 **생성자를 통해서 주입(연결)** 해준다.

- 설계의 변경으로 MemberServiceImpl 은 MemoryMemberRepository 에 의존하지 않는다.
- 단지 인터페이스인 MemberRepository 에만 의존하고 있다.
- MemberServiceImpl 입장에서는 **생성자를 통해 어떤 구현 객체가 주입될지는 알 수가 없다**.
- MemberServiceImpl 의 생성자를 통해서 어떤 구현 객체를 주입할지는 오직 외부인 AppConfig 에서 결정된다.
- MemberServiceImpl 은 이제부터 의존관계에 대한 고민은 외부에 맡기고 오직 **실행에만 집중**할 수 있다.

구현체인 MemberServiceImpl 입장에서는 의존관계를 마치 **외부에서 주입(외부에서 생성자를 통해 주입)해주는 것 같다고해서 DI(Dependency Injection) -> 의존관계 주입 또는 의존성 주입**이라고 한다.

## 정리
- AppConfig 를 통해서 관심사를 확실하게 분리했다.
- 배역과 배우를 생각해보면 된다.
- AppConfig 는 공연 기획자이다.
- AppConfig 는 구체 클래스를 선택한다. 배역에 맞는 담당 배우를 선택한다. 어플리케이션이 어떻게 동작해야 할지 전체 구성을 책임진다.
- 전에는 각 배우들이 섭외와 공연을 같이 해야 했다면, 이제는 기획자(AppConfig)가 있기 때문에 각 배우들(구현체들)은 **담당 기능을 실행(공연)하는 책임**만 지면 된다.
- MemberServiceImpl 는 기능을 실행하는 책임만 지면된다.
- 각 구현체들은 인터페이스만 보고 개발하면된다. 구체 클래스가 뭐가 될지에 대한 것은 전혀 고민할 필요가 없는 것이다.