# 롬복과 최신 트렌드
개발을 하다보면 대부분 불변이기에, 생성자에 `final` 키워드를 사용하게 된다.   
그런데 생성자도 만들고, 주입 받은 값을 대입하는 코드도 만들어야 하는 귀찮은 일이 생긴다.

```java
@Component
public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;

    @Autowired
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }
//...
```

위 코드에 롬복이라는 라이브러리를 적용하면 간단해진다.
- 롬복: 자바에 Getter, Setter 와 같은 메서드를 만들어주는 등에 반복 소스코드를 컴파일 과정에서 생성해주는 방식으로 동작하는 라이브러리이다.

`build.gradle` 에 아래 설정을 추가해주면 된다.
```java
// lombok 설정 추가 시작
configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}
// lombok 설정 추가 끝

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter'
    implementation 'org.jetbrains:annotations:20.1.0'
    
    //lombok 라이브러리 추가 시작
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    testCompileOnly 'org.projectlombok:lombok'
    testAnnotationProcessor 'org.projectlombok:lombok'
    //lombok 라이브러리 추가 끝
    
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```
<img width="532" alt="image" src="https://user-images.githubusercontent.com/63203480/199526862-a3e10787-37d5-4dfb-a5f0-0bdb067a3977.png">

<img width="703" alt="image" src="https://user-images.githubusercontent.com/63203480/199526504-31019668-897d-4f17-9252-006ff8460f22.png">

인텔리제이에서는 gradle 변경 시 나오는 코끼리모양과 두 번째 사진에서의 체크표시를 눌러주면 라이브러리가 적용된다.

<img width="552" alt="image" src="https://user-images.githubusercontent.com/63203480/199744990-a2299ec4-413e-4efa-b590-12963dcbc307.png">

그리고 위의 사진처럼 IntelliJ 에서 `preference -> Annotation Processors -> Enable annotation processing` 을 체크해줘야 한다.
그렇게 되면 인텔리제이에서 롬복을 사용할 수 있게 된다.

```java
package hello.core;

import lombok.Getter;
import lombok.Setter;

@Getter
@Setter
@ToString 
public class HelloLombok {
    private String name;
    private int age;

    public static void main(String[] args) {
        HelloLombok helloLombok = new HelloLombok();
        helloLombok.setName("age");

        String name = helloLombok.getName();
        System.out.println("name = " +name);
        System.out.println("helloLombok =" + helloLombok);
    }
}
```
대표적으로 `@Getter, @Setter` 를 통해서 자동으로 Getter 와 Setter 를 만들어준다. 많은 기능들이 있기 때문에 참고하면 좋다.       
주로 `@Getter` 를 많이 사용한다.

`@RequiredArgsConstructor` 는 생성자를 자동으로 만들어준다. 보이지는 않지만 실제 호출이 가능하다.
```java
@Component
@RequiredArgsConstructor
public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;

    // 이 부분을 똑같이 만들어준다.
//    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
//        this.memberRepository = memberRepository;
//        this.discountPolicy = discountPolicy;
//    }
```
final 이 붙으면 반드시 필수 값이 되기 때문에 RequiredArgs 이름처럼 final 이 붙은 것을 파라미터로 받는 생성자를 만들어준다.     
`cmd + f12` 를 누르면 생성자가 만들어진 것을 확인할 수 있다.

<img width="472" alt="스크린샷 2022-11-03 오후 11 36 57" src="https://user-images.githubusercontent.com/63203480/199750539-edc07fae-cbc4-46d3-b8b8-8c2e9d04d577.png">

```java
@Autowired private MemberRepository memberRepository;
@Autowired private DiscountPolicy discountPolicy;
```

`@Autowired` 을 변수에 붙이는 것보다 좋다. 왜냐하면 final 과 생성자를 모두 사용할 수 있기 때문이다.    
가끔 생성자가 필요한 경우에만 직접 만들어서 사용한다.    
롬복의 `@RequiredArgsConstructor` 를 사용하면 의존관계를 추가할 때 매우 편해진다. 단, 한 줄만 추가하면 되기 때문이다.
```java
@Component
@RequiredArgsConstructor
public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;
    private final Object object; // 추가
```

즉, 롬복이 자바의 에노테이션 프로세서라는 기능을 이요해서 **컴파일 시점에 생성자 코드를 자동으로 생성**해준다. 
실제 class 를 열어보면 코드가 추가되어 있는 것을 확인할 수 있다.
