## 다양한 의존관계 주입방법
1. 생성자 주입
2. 수정자 주입
3. 필드 주입
4. 일반 메서드 주입

### 생성자 주입
```java
@Component
public class OrderServiceImpl implements OrderService {
    private final MemberRepository memberRepository;
    private final DiscountPolicy discountPolicy;

    @Autowired
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }
    //...
}
```

Component 스캔을 할 시점에 `@Component`  가 붙은 클래스가 스프링 빈에 등록될 시점에 생성자를 호출하게 되는데 `@Autowired` 가 있다면 스프링 컨테이너에서 스프링 빈을 꺼내서 주입을 해주는 것이다.

생성자 호출시점에 딱 1번만 호출되는 것을 보장한다. 따라서 불변이나 필수 의존관계 주입이 필요할 때 사용한다. 즉, 한 번만 셋팅을 하고 그 다음부터는 셋팅을 하지 못하게 막을 수 있다는 것이다. 위의 코드에서는 생성자를 통해서만 의존관계가 주입이되고, 어느 누구도 주입된 객체를 수정할 수 없다.     
수정자 메서드나 세터메서드를 만들지 않아서 불변 객체를 만들지 않아야 한다.

그리고 `private final` 을 통해 필수로 값을 셋팅하도록 해야 한다.

만약 생성자가 하나라면 `@Autowired` 를 생략해도 된다. 자동으로 의존관계를 주입해준다.

```java
// Autowired 셍략 가능
public class OrderServiceImpl implements OrderService {
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }

    // 생략 불가능
    public class OrderServiceImpl implements OrderService {
        @Autowired
        public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
            this.memberRepository = memberRepository;
            this.discountPolicy = discountPolicy;
        }

        @Autowired
        public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
            this.memberRepository = memberRepository;
            this.discountPolicy = discountPolicy;
        }
```

당연하게도 스프링 빈에만 해당되는 것이다.

### 수정자 주입
필드 값을 직접 수정하지 않고 메서드를 통해 수정하는 것을 수정자라고 한다.

```java
@Component
public class OrderServiceImpl implements OrderService {
    private MemberRepository memberRepository;
    private DiscountPolicy discountPolicy;

    @Autowired
    public void setMemberRepository(MemberRepository memberRepository) {
        System.out.println("memberRepository = " + memberRepository);
        this.memberRepository = memberRepository;
    }

    @Autowired
    public void setDiscountPolicy(DiscountPolicy discountPolicy) {
        System.out.println("discountPolicy = " + discountPolicy);
        this.discountPolicy = discountPolicy;
    }
```

스프링 컨테이너는 크게 2가지의 라이프사이클이 있다. 스프링 빈을 다 등록하고,  연관관계를 자동으로 주입한다. `@Autowired` 가 걸려있는 것들을 자동 주입하는 것이다.    
생성자 주입은 빈을 등록할 때 일어나는 것이고, 수정자는 주입단계에서 일어나게 된다.

```java
// 생성자는 객체를 만들 때 언어상 반드시 넣어줘야 하기 때문에 스프링 빈에 등록되는 시점에 주입이 발생된다.
new OrderServiceImpl(memberRepository, discountPolicy);
```

생성자와 수정자 주입이 모두 있을 경우에는 모두 호출이 된다. 순서는 생성자 주입 -> 수정자 주입이다.

```java
@Component
public class OrderServiceImpl implements OrderService {
    private MemberRepository memberRepository;
    private DiscountPolicy discountPolicy;

    @Autowired
    public void setMemberRepository(MemberRepository memberRepository) {
        System.out.println("memberRepository = " + memberRepository);
        this.memberRepository = memberRepository;
    }

    @Autowired
    public void setDiscountPolicy(DiscountPolicy discountPolicy) {
        System.out.println("discountPolicy = " + discountPolicy);
        this.discountPolicy = discountPolicy;
    }

    @Autowired
    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {
        System.out.println("OrderServiceImpl");
        this.memberRepository = memberRepository;
        this.discountPolicy = discountPolicy;
    }
```

<img width="561" alt="image" src="https://user-images.githubusercontent.com/63203480/195372981-3c17bd47-4c4d-4ef9-b68a-5169469fd35e.png">

수정자 주입은 선택적이고, 변경 가능성이 있는 의존관계에서 사용한다.
만약 사용하려는 객체가 빈에 등록이 되지 않을 경우에도 사용이 가능한 것이다.
`@Autowired(required = false)` 를 통해 선택적으로 사용할 수 있다.       
또한 외부에서 인스턴스를 변경하고 싶다면 set 메서드를 호출해서 변경할 수도 있다. 이러한 경우는 거의 없을 것이다.

`@Autowired` 의 기본동작은 주입할 대상이 없으면 오류가 발생하기 때문에 대상이 없더라도 동작하게 하려면 `required = false` 옵션을 줘야 한다.

자바에서는 과거부터 필드의 값을 직접 변경하지 않고, setXXX, getXXX 라는 메서드를 통해서 값을 읽거나 수정하는 규칙을 만들었는데, 그것이 자바빈 프로퍼티 규약이다.

### 필드 주입
필드에 값을 바로 주입하는 방법이다.

```java
@Component  
public class OrderServiceImpl implements OrderService {  
    @Autowired private MemberRepository memberRepository;  
    @Autowired private DiscountPolicy discountPolicy;
```

위와 같이 필드에 `@Autowired` 만 추가해주면 된다. 매우 심플하고 좋은 방법이지만 추천하지 않는 방법이다.

<img width="350" alt="스크린샷 2022-10-13 오후 11 41 47" src="https://user-images.githubusercontent.com/63203480/195628116-785993b0-9388-421a-868b-fa3d082c9198.png">

실제로 스프링에서도 경고를 보내준다. 왜냐하면 외부에서 변경이 불가능하기 떄문에 테스트하기 힘들다는 치명적인 단점이 있다.

예를 들면 MemberRepository 를 테스트를 위해 가짜 MemberRepository 로 바꾸고 싶지만 필드 주입을 사용한 경우에는 순수한 자바 코드로 바꿀 수 있는 방법이 존재하지 않게 된다.

```java
@Component  
public class OrderServiceImpl implements OrderService {  
    @Autowired private MemberRepository memberRepository;  
    @Autowired private DiscountPolicy discountPolicy;  

    @Override  
    public Order createOrder(Long memberId, String itemName, int itemPrice) {  
        Member member = memberRepository.findById(memberId);  
  
        // 이 로직이 설계가 잘된 이유는 할인관련된 로직은 Order 자신이 관여하지 않아도 되기 때문이다.  
        int discountPrice = discountPolicy.discount(member, itemPrice);  
        return new Order(memberId, itemName, itemPrice, discountPrice);  
    }
//...
@Test  
void fieldInjectionTest() {  
    OrderServiceImpl orderService = new OrderServiceImpl();  
    orderService.createOrder();  
}
```

순수 자바를 통해  `OrderServiceImpl` 객체를 생성해서 테스트하려고 시도하면 MemberRepository 와 DiscountPolicy 가 없는 값이기 때문에 `NullPointerException` 이 발생하게 된다.  하지만 필요한 값을 넣어주려고 해도 넣어줄 수 있는 방법이 존재하지 않는다.      
결과적으로 추가로 setter 를 만들어서 넣어주는 방법을 사용해야 한다.

```java
@Component  
public class OrderServiceImpl implements OrderService {  
    @Autowired private MemberRepository memberRepository;  
    @Autowired private DiscountPolicy discountPolicy;  

    @Override  
    public Order createOrder(Long memberId, String itemName, int itemPrice) {  
        Member member = memberRepository.findById(memberId);  
  
        // 이 로직이 설계가 잘된 이유는 할인관련된 로직은 Order 자신이 관여하지 않아도 되기 때문이다.  
        int discountPrice = discountPolicy.discount(member, itemPrice);  
        return new Order(memberId, itemName, itemPrice, discountPrice);  
    }
    
    public void setMemberRepository(MemberRepository memberRepository) {  
	    System.out.println("memberRepository = " + memberRepository);  
	    this.memberRepository = memberRepository;  
	}
//...
@Test  
void fieldInjectionTest() {  
    OrderServiceImpl orderService = new OrderServiceImpl();  
    orderService.setMemberRepository(new MemoryMemberRepository());
    
    orderService.createOrder();  
}
```

필드 주입을 하게 되면 결국 테스트를 위해서 setter 를 만들어줘야 한다. 따라서 필드 주입은 최근에 사용하지 않고 사용하면 안된다. DI 프레임워크가 없다면 아무것도 할 수가 없다.

### 일반 메서드 주입
```java
@Autowired  
public void init(MemberRepository memberRepository, DiscountPolicy discountPolicy) {  
    this.memberRepository = memberRepository;  
    this.discountPolicy = discountPolicy;  
}
```

위와 같이 일반 메서드에 `@Autowired` 설정을 하면 자동으로 주입이 된다. 수정자 주입과 비슷하다.     
한 번에 여러 필드를 주입 받을 수 있다는 특징이 있다. 일반적으로 사용하지는 않는다.

참고로 의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 빈이어야 동작한다.

```java
@Component  
public class OrderServiceImpl implements OrderService {
```

스프링 빈이 아닌 클래스에서 `@Autowired` 코드를 적용해도 아무 기능도 동작하지 않는다.
