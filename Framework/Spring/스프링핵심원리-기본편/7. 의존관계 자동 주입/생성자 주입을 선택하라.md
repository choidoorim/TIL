### 불변
- 대분의 의존관계 주입은 한번 일어나면 어플리케이션 종료시점까지 의존관계를 변경할 일이 없다. 오히려 대부분의 의존관계는 어플리케이션 종료 전까지 변하면 안된다.
- 수정자 주입을 사용하면, setXXX 메서드를 Public 으로 열어놔야 한다.
- 누군가 실수로 변경할 수도 있고, 변경하면 안되는 메서드를 열어두는 것은 좋은 설계 방법이 아니다.
- 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이후에 호출되는 일이 없다. 따라서 불변하게 설계할 수 있다.

### 누락
프레임워크 없이 순수한 자바 코드를 단위 테스트 하는 경우가 빈번하게 이뤄진다. 그런 경우에 가짜 객체를 주입해서 사용한다.

```java
@Component  
public class OrderServiceImpl implements OrderService {  
    private MemberRepository memberRepository;  
    private DiscountPolicy discountPolicy;  
  
    @Autowired  
    public void setMemberRepository(MemberRepository memberRepository) {  
        this.memberRepository = memberRepository;  
    }  
  
    @Autowired  
    public void setDiscountPolicy(DiscountPolicy discountPolicy) {  
        this.discountPolicy = discountPolicy;  
    }  

    @Override  
    public Order createOrder(Long memberId, String itemName, int itemPrice) {  
        Member member = memberRepository.findById(memberId);  
  
        // 이 로직이 설계가 잘된 이유는 할인관련된 로직은 Order 자신이 관여하지 않아도 되기 때문이다.  
        int discountPrice = discountPolicy.discount(member, itemPrice);  
        return new Order(memberId, itemName, itemPrice, discountPrice);  
    }
    //...
}
```

```java
@Test  
void createOrder() {  
    OrderServiceImpl orderService = new OrderServiceImpl();  
    orderService.createOrder(1L, "itemA", 10000);  
}
```

만약 위처럼 수정자 주입을 한 뒤, 테스트를 실행하면 `NullPointerException` 이 발생한다.    
왜냐하면 `memberRepository, discountPolicy` 값을 셋팅하지 않았기 때문이다.    
테스트 코드를 짤 때는 실제로 어떤 의존관계가 들어가는지 확인하기 위해서는 직접 클래스에 들어가서 확인해줘야 한다.

```java
@Component  
public class OrderServiceImpl implements OrderService {  
	private final MemberRepository memberRepository;  
	private final DiscountPolicy discountPolicy; 

    public OrderServiceImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) {  
        this.memberRepository = memberRepository;  
        this.discountPolicy = discountPolicy;  
    }
```
<img width="1238" alt="스크린샷 2022-10-17 오후 11 18 54" src="https://user-images.githubusercontent.com/63203480/196201619-3e257b97-9b98-40e2-a281-68ce54710f5f.png">

생성자 주입으로 코드를 변경한다면 컴파일 오류가 발생할 것이다. 생성자는 지정하면 필수 값이기 때문에 `new Class();` 를 하면 어떤 것에 의존하고 있는지를 컴파일 단에서 확인하고 인지할 수 있다.

### final 키워드
생성자 주입을 사용하면 필드에 `final` 키워드를 사용할 수 있다. 즉, 생성자를 통해서만 값을 설정할 수 있다는 것이다.

<img width="749" alt="스크린샷 2022-10-17 오후 11 23 41" src="https://user-images.githubusercontent.com/63203480/196202778-eb5c51c6-2426-4430-ae03-de304fdc061e.png">

또한 만약 개발자가 실수로 값을 누락할 수도 있다. 그럴 경우 `final` 키워드 때문에 컴파일 단에서 인지하고 확인할 수 있다. 하지만 final 키워드가 없다면 에러가 노출되지 않을 것이고, 테스트를 실행해보기 전까지는 이 문제를 확인할 수 없게 된다.

<img width="436" alt="image" src="https://user-images.githubusercontent.com/63203480/196203541-ae566420-4f6f-41ed-9347-ef570c7d73ef.png">

`final` 키워드를 통해 생성자 단계에서 값이 설정되지 않는 오류를 컴파일러 단계에서 막아준다.
- setXxx 와 같은 수정자는 객체가 생성된 다음 단계에 호출이 되는 것이다.
- 생성자 주입을 제외한 주입 방법은 모두 객체 생성 이후에 호출되므로, 필드에 `final` 키워드를 사용할 수 없다.


