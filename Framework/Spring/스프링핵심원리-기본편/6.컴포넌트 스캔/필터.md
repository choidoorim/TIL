`includeFilters` 는 컴포넌트 스캔 대상을 추가로 지정하고, `excludeFilters` 는 컴포넌트 스캔에서 제외할 대상을 지정한다.


```java
@Target(ElementType.TYPE)  
@Retention(RetentionPolicy.RUNTIME)  
@Documented  
public @interface MyIncludeComponent {  
}

@MyIncludeComponent  
public class BeanA {  
}

//------------------------
@Target(ElementType.TYPE)  
@Retention(RetentionPolicy.RUNTIME)  
@Documented  
public @interface MyExcludeComponent {  
}

@MyExcludeComponent  
public class BeanB {  
}
```

```java
public class ComponentFilterAppConfigTest {  
  
    @Test  
    void filterScan() {  
        ApplicationContext ac = new AnnotationConfigApplicationContext(ComponentFilterAppConfig.class);  
        BeanA beanA = ac.getBean("beanA", BeanA.class);  
        Assertions.assertThat(beanA).isNotNull();  
  
        BeanB beanB = ac.getBean("beanB", BeanB.class);  
        Assertions.assertThat(beanB).isNotNull();  
    }  
  
    @Configuration  
    @ComponentScan(  
            includeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = MyIncludeComponent.class),  
            excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = MyExcludeComponent.class)  
    )  
    static class ComponentFilterAppConfig {  
    }  
}
```

BeanA 는 `@ComponentScan` 의  includeFilters 옵션에 MyIncludeComponent 에노테이션을 추가했기 때문에 BeanA 는 스프링 빈에 등록된다.   
하지만 BeanB 는 excludeFilters 옵션에 MyExcludeComponent 에노테이션을 추가했기 때문에 스프링 빈에 등록되지 않는다.

### FilterType 옵션
- `ANNOTAION` : 기본 값이며, 에노테이션을 인식해서 동작한다.
- `ASSIGNABLE_TYPE` : 지정한 타입과 자식 타입을 인식해서 동작한다. 직접 클래스를 지정할 수 있다.
    - ex) `@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, classes = BeanA.class)`
- `ASPECTJ` : ASPECTJ 라는 패턴을 사용해서 찾는 것이다.
- `REGEX` : 정규 표현식을 사용할 수도 있다.
- `CUSTOM` : `TypeFilter` 이라는 인터페이스를 직접 구현해서 처리할 수도 있다.

> 참고:
> `@Component` 만으로 충분하기 때문에, `includeFilters` 를 사용할 일은 거의 없다. `excludeFilters` 는 여러 가지 이유로 간혹 사용할 때가 있지만 흔한 경우는 아니다.
> 스프링 부트가 컴포넌트 스캔을 기본으로 제공하기 때문에, 개인적으로 옵션을 변경하면서 사용하기 보다는 스프링 **기본 설정에 최대한 맞추어 사용하는 것을 권장하고, 선호하는 편**이라고 한다.

