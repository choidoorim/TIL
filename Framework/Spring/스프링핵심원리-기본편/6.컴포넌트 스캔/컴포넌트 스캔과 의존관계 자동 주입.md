스프링 빈을 등록할 때 자바 코드의 `@Bean` 이나 XML 의 bean 등을 통해서 설ㅓㅇ 정보에 직접 등록한 스프링 빈을 나열했다. 만약 등록해야 할 스프링 빈이 수십, 수백개가 된다면 일일이 등록하기도 귀찮고, 설정 정보도 커지고, 누락하는 문제도 발생한다. 따라서 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다. 또한 의존 관계도 자동으로 주입하는 `@Autowired` 라는 기능도 존재한다.

`@ComponentScan` 은 Component Annotation 이 붙은 클래스를 모두 찾아 빈으로 등록을 해준다. 또한 filter 를 통해 빈으로 등록하지 않을 것을 지정할 수도 있다. 그리고 빈으로 등록한 클래스가 `AutoAppConfig` 클래스에는 단 하나도 없다.

```java
@ComponentScan(  
        excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Configuration.class)  
)
public class AutoAppConfig {
}
```

`@Configuration` 이 붙은 클래스를 확인해보면 자동으로 `@Component` 가 붙어 있기 때문에 만약 수동으로 빈을 등록하는 클래스가 있다면 제외시켜줘야 충돌을 방지할 수 있다.

<img width="283" alt="스크린샷 2022-10-04 오후 9 39 33" src="https://user-images.githubusercontent.com/63203480/193821497-910b436e-bd11-43cb-9758-a5832fcc07dd.png">

보통은 설정 정보를 컴포넌트 스캔 대상에서 제외하지는 않는다. 실무에서는 ComponentScan 을 사용해서 빈을 등록한다.

`@Component` 를 클래스에 붙여서 스프링 빈에 등록할 수 있다.

```java
@Component  
public class MemberServiceImpl implements MemberService {  
    private final MemberRepository memberRepository;  
  
    public MemberServiceImpl(MemberRepository memberRepository) {  
        this.memberRepository = memberRepository;  
    }
```

근데  `MemberServiceImpl` 클래스를 빈으로 등록한다면 생성자 주입은 어떻게 해야되나?     
따라서 자동 의존 관계 주입이 필요하다. 자동 의존 관계 주입인 `@Autowired` 를 생성자에 붙여주면 `MemberRepository` 라는 타입에 맞는 클래스를 찾아와서 의존관계 주입을 자동으로 해준다.

```java
@Component  
public class MemberServiceImpl implements MemberService {  
    private final MemberRepository memberRepository;  

	@Autowired  // ac.getBean(MemberRepository.class)
    public MemberServiceImpl(MemberRepository memberRepository) {  
        this.memberRepository = memberRepository;  
    }
```

이전 AppConfig 에서는 `@Bean` 으로 직접 설정 정보를 작성했고, 의존관계도 직접 명시했다. 하지만 이런 설정 정보 자체가 없어지는 것이기 때문에 클래스 내부에서 해결해야 되는 것이다.

```java
@Configuration  
public class AppConfig {  
    @Bean()  
    public MemberRepository memberRepository() {  
        return new MemoryMemberRepository();  
    }  
    @Bean  
    public MemberService memberService() {  
        return new MemberServiceImpl(memberRepository());  
    }
```

실제로 `AnnotationConfigApplicationContext` 를 통해 빈을 조회해보면 잘 동작하는 것을 확인할 수 있다.

```java
public class AutoAppConfigTest {  
  
    @Test  
    void basicScan() {  
        AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AutoAppConfig.class);  
  
        MemberService memberService = ac.getBean(MemberService.class);  
        Assertions.assertThat(memberService).isInstanceOf(MemberService.class);  
    }  
}
```

## 컴포넌트 스캔과 자동 의존관계 주입 동작 방식

### 1. @ComponentScan
`@ComponentScan` 은 `@Component` 가 붙은 모든 클래스를 스프링 빈으로 등록한다.     
이때 빈 이름은 클래스명을 사용하되 맨 앞글자만 소문자를 사용한다. MemberServiceImpl 클래스는 **memberServiceImpl** 이 되는 것이다. 만약 직접 지정하고 싶다면 `@Component("memberService")`  처럼 이름을 부여할 수도 있다. 특별한 경우에만 직접 이름을 지정한다.

### 2. @Autowired 의존관계 자동 주입
생성자에 `@Autowired` 를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.

```java
@Autowired
public MemberServiceImpl(MemberRepository memberRepository) {  
	this.memberRepository = memberRepository;  
}
```

조회의 기본 전략을 타입이 같은 빈을 찾아서 주입하는 것이다. `ac.getBean(MemberRepository.class)` 와 동일하다고 이해하면 된다. 만약 위와 같다면 MemberRepository 타입을 찾아서 주입을 해주는 것이다. 
