### SRP(Single Responsibility Principle) - 단일 책임 원칙
**"하나의 클래스는 하나의 책임만 가져야 한다"** 라는 것이다. 중요한 판단의 기준은 **변경** 이라고 볼 수 있다.        

변경이 있을 때 **파급이 적다면** 단일 책임 원칙을 잘 지켜 설계했다고 볼 수 있다. 객체의 생성과 사용을 분리하는 것이다.

### OCP(Open/Closed Principle) - 개방-폐쇄 원칙(중요!!)
**"확장에는 열려있으나 변경에는 닫혀있어야 한다"** 라는 것이다. 하지만 코드의 변경 없이 확장이 될 수 있을까?
다형성을 활용하면 이 다형성을 잘 활용할 수 있다.   

인터페이스를 구현한 새로운 클래스를 하나 만드는 것은 기존 코드를 변경하는 것이 아니다. 따라서 새로운 클래스를 하나 만들어서 새로운 기능을 구현하는 것이다.
즉, **다형성을 활용**하면 확장에는 열려있으나 변경에는 닫혀있게 만들 수 있다.

하지만 문제가 있다.
아래 코드처럼 구현 객체를 변경하기 위해서는 클라이언트 코드(service(client) -> repository)를 반드시 변경해야 한다.
```java
public class MemberService {
	// MemberRepository m = new MemoryMemberRepository(); // 기존 코드
	MemberRepository m = new JdbcMemberRepository(); // 변경 코드
}
```
인터페이스와 구현체를 잘 만들어서 다형성을 이용했지만 OCP 가 깨지게 된다.

이것을 해결하기 위해서는 객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다. 
스프링 컨테이너가 이러한 역할을 하고, OCP 를 정확히 지키기 위해서는 **DI, IoC 컨테이너**가 필요하다.

### LSP(Liskov Substitution Principle) - 리스코프 치환 원칙
"프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다" 라는 것이다.
인터페이스의 규약을 무조건 맞추고 기능적으로 보장해야 한다는 것이다. 예를 들면 자동차 인터페이스의 엑셀은 앞으로 가라는 기능이지만, 뒤로 가도록 구현해도 컴파일 단에 오류는 발생하지 않는다. 엑셀은 앞으로 가야된다는 규약이 있기 때문에 이것은 LSP 를 위반한 것이다.

### ISP(Interface Segregation Principle) - 인터페이스 분리 원칙
"특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다"라는 것이다.
예를 들어 자동차 인터페이스에 운전관련, 정비 관련 기능들이 있을 수도 있다. 자동차 인터페이스가 너무 크기 때문에 운전과 정비 관련 인터페이스를 분리하는 것이다.
이것의 장점은 사용자 클라이언트를 운전사/정비사 클라이언트로 나눌 수 있다. 만약 정비 인터페이스에 문제가 있다면 정비 인터페이스와 정비사 인터페이스 부분만 바꾸면 되고 운전자와 운전 인터페이스는 변경할 필요가 없게 된다.

결과적으로 인터페이스가 명확해지고, 대체 가능성이 높아진다.


### DIP(Dependency Inversion Principle) - 의존 관계 역전 원칙(중요!!)
"프로그래머는 추상화에 의존해야지 구체화에 의존하면 안된다" 라는 것이다. 의존성 주입은 이 원칙을 따르는 방법 중 하나이다.
쉽게 말하면 클라이언트의 코드는 구현 코드를 바라보는 것이 아닌, 인터페이스만 바라보라는 것이다. 시스템을 설계할 때는 역할과 구현을 철저하게 분리하도록 설계하여 시스템을 언제든지 바꿀 수 있도록 해야 한다.
그게 가능하려면 **역할에 의존해야지 구현에 의존하면 안된다**.
객체 세상도 **클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경**할 수 있다. 구현체에 의존하게 되면 변경이 아주 어려워지게 된다.

```java
public class MemberService {
	MemberRepository memberRepository = new MemoryMemberRepository();
}
```

위 코드는 MemberService 클라이언트가 MemberRepository 라는 인터페이스만 아는 것이 아니라 MemoryMemberRepository 라는 구현체까지 알고 있는 것이다. MemberRepository 를 변경하기 위해서는 MemberService 클라이언트를 변경하게 된다. 즉, MemberService 는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존하는 것이다.
MemberService 클라이언트가 구현 클래스인 `MemoryMemberRepository` 를 직접 선택하고 있기 때문에 DIP 에 위반된다.


## 정리
- **객체지향의 핵심은 다형성**이다.
- 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.
- 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
- 다형성 만으로는 OCP, DIP 를 지킬 수 없다.