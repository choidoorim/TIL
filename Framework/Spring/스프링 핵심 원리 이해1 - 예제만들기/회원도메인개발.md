```java
private static Map<Long, Member> store = new HashMap<>();

private static ConcurrentHashMap<Long, Member> store = new ConcurrentHashMap<>();
```

동시성 이슈가 있을 수도 있기 때문에 Java 에서 Map 보다는 ***ConcurrentHashMap** 을 사용하는 것이 더 좋다.
단순히 개발용도에서만 사용하고 실무에서는 사용하지 않는다.

- **Map**: 성능이 가장 좋지만, 동시성을 지원하지 않기 때문에 멀티 스레드 환경에서는 사용하지 않는 것이 좋다.
- **ConcurrentHashMap**: Hashtable 클래스의 단점을 보완하면서 멀티 스레드 환경에서 사용할 수 있다. 동기화가 추가되기에 읽기 속도는 비교적 느리다.

```java
public class MemberServiceImpl implements MemberService {  
    private final MemberRepository memberRepository = new MemoryMemberRepository();  
  
    @Override  
    public void join(Member member) {  
        memberRepository.save(member);  
    }  
  
    @Override  
    public Member findMember(Long memberId) {  
        return memberRepository.findById(memberId);  
    }  
}
```
관례상 구현체가 하나만 있을 경우 **Interface 명 + Impl**(MemberServiceImpl) 이라고 네이밍을 한다.

Type 은 Interface 로 Interface 를 의존(```MemberRepository memberRepository```)하지만 실질적으로 구현체를 의존(```new MemoryMemberRepository()```)하고 있기 때문에 OCP, DIP 원칙을 지키지 못하고 있다. 
즉, MemberServiceImpl 클래스는 **추상화에도 의존하고, 구현체에도 의존**하고 있는 것이다.
