## 해시(Hash)
데이터를 다루는 기법 중 하나로 검색과 저장이 아주 빠르게 진행되는 특징이 있습니다. 빠르게 진행될 수 있는 이유는
데이터를 검색할 때 사용할 key 와 실제 데이터의 값이 한 쌍으로 존재하고, key 값이 배열의 인덱스로 변환되기 때문에 검색과 
저장의 평균적인 **시간 복잡도가 O(1)** 이 됩니다.   

### 해시 함수
데이터의 효율적 관리를 목적으로 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수입니다.   
매핑 전 원래 데이터 값을 **key**, 매핑 후 데이터의 값을 **해시 값(value)**라고 하며,
매핑하는 과정 자체를 **해싱**이라고 합니다.   
데이터가 많아지게 된다면, 다른 key 가 같은 해시 값으로 인해 **충돌(Collision)** 나는 현상이 발생합니다.
```
A -> 해시 함수 -> 1
B -> 해시 함수 -> 6
C -> 해시 함수 -> 3
-----
D -> 해시 함수 -> 6   // B 의 해시 값과 충돌
```
![collision](https://user-images.githubusercontent.com/63203480/134488338-9b9b49cd-2559-4078-a3a3-00dc94540f4c.png)

### 해시 테이블
해시 함수를 사용하여 키를 해시 값으로 매핑하고, 해시 값을 index 나 주소 삼아 데이터의 값을 
키와 함께 저장하는 자료구조를 해시테이블이라고 합니다.

### 해시 테이블을 사용하는 이유
적은 자원으로 많은 데이터를 효율적으로 관리할 수 있기 때문이다.  
하드디스크나 클라우드에 존재하는 무한에 가까운 데이터(key)들을 유한한 개수의 해시 값으로 매핑함으로써 
작은 크기의 캐시 메모리로도 프로세스를 관리할 수 있게 된다.   
- 언제나 동일한 해시 값을 return 하고, 해당 index 만 알면 
해시 테이블의 크기에 상관없이 데이터에 아주 빠르게 접근할 수 있다.
  
### Collision 을 해결하기 위한 방법
1. 체이닝 : 연결리스트로 노드를 계속해서 추가하는 방식, 모든 자료를 해시테이블에 담는 것.
    - 제한 없이 계속 데이터를 연결할 수 있지만, 메모리 문제가 있다.
      ![1](https://user-images.githubusercontent.com/63203480/134490458-c4403dfc-9a08-477f-a3da-f6173b2bfba7.png)
2. open addressing : 해시 함수로 얻은 주소가 아닌 다른 주소에 데이터를 저장할 수 있도록 허용하는 방식
    - 해당 키 값에 저장되어 있을 경우 다음 주소에 저장
    
3. 선형 탐사 : 최초 해시 값에 저장되어 있을 경우 정해진 고정 폭으로 옮겨 접근하는 방식으로 해시 값의 중복을 피한다.
4. 제곱 탐사 : 최초 해시 값에 저장되어 있을 경우 정해진 고정 폭을 제곱수로 옮겨 접근하는 방식으로 해시 값의 중복을 피한다.
