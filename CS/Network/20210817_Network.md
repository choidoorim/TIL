인터넷은 LAN과 WAN들의 조합으로 이루어진 인터넷 네트워크입니다.

![1](https://user-images.githubusercontent.com/63203480/129694769-0367f5a7-7dbd-44a9-8892-7f03a00daaaf.PNG)

라우터와 같은 Connection device는 교환기로서 동작합니다. 데이터가 라우터의 한 포트에 도착하게 되면 이 데이터는 다른 포트를 통하여 다음 Connection device 혹은 최종 목적지로 포워드 됩니다. 즉, Connection device에서 Switching 이라는 과정이 수행됩니다.

> **Switching(교환)**

패킷 교환은 회선교환 방법과 패킷 교환 방법을 사용합니다.

**1\. 회선 교환**

회선 교환에서는 전체 메시지가 패킷으로 분할되지 않고 발신지에서 목적지로 전달됩니다.

**2\. 패킷 교환**

현재 지금의 인터넷의 네트워크 계층은 패킷 교환 네트워크입니다.

상위 계층으로부터의 메시지가 관리 가능한 크기의 패킷으로 분할되고 각 패킷이 네트워크를 통해 전달됩니다.

메시지의 발신지는 패큿을 한개 씩 보내고 목적지는 패킷을 하나 씩 받는다. 이 과정에서 목적지는 모든 패킷이 도착하기를 기다렸다가 이후 조립하여 상위 계층에 전달합니다.

> **네트워크 계층에서의 패킷 교환**

원래 인터넷의 네트워크 계층은 비연결형 서비스로 설계되었으나 최근 연결 지향 서비스로 전환되고 있는 추세입니다.

**1\. 비연결형 서비스 - EX) 웹**

![1](https://user-images.githubusercontent.com/63203480/129694866-76a6d4b2-f12f-4e23-95f8-a99ad9e3e2ea.PNG)

-   네트워크 계층이 발신지로부터 목적지까지의 패킷 전달만 책임집니다.
-   인터넷에서 전달되는 여러 개의 패킷들은 독립적인 개체가 되고 같은 메시지에 속한 패킷이라 할지라도 아무런 상관관계가 존재하지 않습니다. 따라서 한 메시지에 속한 패킷 뒤에 같은 메시지에 속한 다른 패킷이 따라 올 수도 있고 **다른 메시지에 속한 패킷이 따라 올 수도 있습니다.**
-   패킷은 헤더에 있는 발신지 주소와 목적지 주소를 기반으로 전달됩니다. 목적지 주소는 어느 곳으로 갈 것인지를 결정하고 발신지 주소는 어느 곳에서 패킷이 왔는지를 알려준다. 라우터는 목적지 주소에 기반하여 포워딩 결정이 내려집니다.

**\* 포워딩** : 컴퓨터 네트워크에서 패킷이 라우터를 지나고 있을 때 하나의 IP주소와 포트번호를 결합하여 통신 요청을 다른 곳으로 넘겨주는 네트워크 주소 변환 방법입니다. **다음 목적지로 패킷을 전달**하는 것입니다.

**2\. 연결형 서비스 - EX) 휴대전화**

![1](https://user-images.githubusercontent.com/63203480/129694925-ffeeaa5a-026c-4f67-b01b-b46c9061de88.PNG)

-   한 메시지에 속한 모든 패킷들 사이에는 관계성이 존재합니다. 모든 데이터가 송신되기 전에 데이터의 경로를 정의하는 가상 회선(virtual circuit)이 생성되어야 합니다. 생성이 된다면 패킷들은 같은 경로를 따라 가게 됩니다.
-   연결형 서비스는 패킷이 목적지와 발신지는 물론이고, 가상 회선을 정의하는 가상 회선 식별자인 흐름 레이블도 가지고 있어야 합니다.
-   **각 패킷은 패킷 내의 레이블에 기반하여 포워드**됩니다. **포워딩 결정은 레이블(=가상 회선 식별자) 값에 기반**하여 내려집니다.
-   연결 지향 서비스를 생성하기 위하여 설정, 데이터 전송, 해제 3가지 단계 과정이 적용됩니다.

> **발신지 컴퓨터 네트워크 계층에서 제공되는 서비스**

![1](https://user-images.githubusercontent.com/63203480/129694984-09d957bb-7f49-4cb1-805c-43befbaf7fdb.PNG)

**1\. 패킷화(Packetizing)**

네트워크 계층의 첫 번째 임무는 상위계층으로부터 내려온 데이터를 데이터그램으로 캡슐화하는 것입니다.

캡슐화 하는 과정은 데이터에 여러가지 **정보를 담은 헤더를 추가**하는 것입니다.

-   정보: 패킷의 발신지와 목적지의 논리 주소, 단편화에 대한 정보, 서비스를 요청한 프로토콜의 프로토콜 ID, 데이터 길이 등

**2\. 다음 홉의 논리 주소 찾기**

목적지의 컴퓨터가 발신지와 같은 네트워크에 연결되어 있지 않다면 데이터그램은 다음 라우터에 전달되어야 합니다.

발신지 컴퓨터의 네트워크 계층은 라우팅 테이블을 참조하여 다음 홉의 IP주소를 찾아야 합니다.

\* **라우팅** : 최적의 경로를 선택하는 과정

**3\. 다음 홉의 MAC 주소 찾기**

네트워크 계층은 실제로 다음 홉에 데이터그램을 전달하지 않고 데이터 링크 계층에 전달을 맡깁니다. 전달을 위해서는 데이터링크 계층은 다음 홉의 MAC주소를 필요로 합니다. **논리 주소를 MAC주소로 변환하기 위해서는 ARP(Address Resolution Protocol)**이라 불리는 보조 프로토콜에 할당됩니다.

\* **ARP** : 송신자는 수신자의 IP 와 MAC 주소를 알아야 하는데, 논리 주소를 물리 주소로 변환하는 역할을 합니다.

**4\. 단편화(Fragment)**

LAN과 WAN은 한 프레임에 전달할 수 있는 **최대 데이터 크기**를 가지고 있고, 이 최대 크기를 **MTU**라고 합니다.

네트워크 계층에서 준비된 데이터그램은 MTU보다 클 수 있는데, 이러한 경우 데이터그램은 데이터링크 계층에 전달되기 전에 작은 크기로 단편화되어야 합니다.

단편화 과정에서 데이터는 단편화되더라도 데이터그램의 헤더에 필요한 정보는 유지해야 합니다.

예제) naver.com 에 접속

1-1. DNS Lookup : 도메인 네임을 통해 IP 주소를 알아낸다.

1-2. Packetizing

1-3. naver.com 의 IP주소

2. IPm 경로 설정 -> routing table lookup


3. routing Table을 통해 다음 홉의 IP주소 획득


4. ARP에서 IP주소를 통해 MAC주소 획득


5. frame 구성(=fragment)

> **목적지 컴퓨터 네트워크 계층에서 제공되는 서비스**

![1](https://user-images.githubusercontent.com/63203480/129695284-c0b75a93-4649-4cef-a86f-3dfec5bd5f43.PNG)

포워딩은 더 이상 필요하지 않고, 모든 프레임 데이터가 도착하면 **데이터를 재조립하고 상위 계층에 전달**합니다.

네트워크 계층은 재조립을 위한 타이머를 설정하는데, 만약 **타이머가 만료**된다면 모든 프레임들은 폐기되고 모든 데이터가 재전송되어야 한다는 **오류 메시지가 전송**됩니다.

> **IPv4**

![1](https://user-images.githubusercontent.com/63203480/129695343-2d7f5b47-93e3-4c17-9146-735b79a40674.PNG)

-   네트워크 계층에서 모든 장치들 간에 전 세계적으로 통신을 할 수 있도록 인터넷에 연결된 모든 장치들을 유일하게 구분할 수 있는 방법이다.
-   32비트 주소로서 인터넷에 있는 호스트나 라우터의 연결을 유일하고 보편적으로 나타냅니다.
-   IPv4 프로토콜은 주소 공간을 가지고 있는데 32비트의 주소를 가지므로 주소공간은 2^32인 4,294,967,296개로 40억 이상입니다.
-   **IPv6** : IPv4 주소가 32비트로 제한적이기에 거의 다 소진되어 이에 대한 해결책으로 나온 프로토콜입니다.
-   인터넷 프로토콜(IP)은 네트워크 계층에서 TCP/IP 프로토콜이 사용하는 전송 매커니즘입니다.

![1](https://user-images.githubusercontent.com/63203480/129695415-9ad60970-281f-4c0f-a739-ec55a414fe16.PNG)

> **데이터 그램**

인터넷(네트워크) 계층의 패킷은 데이터그램이라고 합니다.

**1\. IP 데이터 그램의 헤더**

![1](https://user-images.githubusercontent.com/63203480/129695499-30febf05-de1e-4c66-b026-2326bc1a9623.PNG)

-   **VER**(버전) : IP 프로토콜의 버전을 나타냅니다.
-   **HLEN**(헤더 길이) : 데이터 그램 헤더의 전체 길이를 4바이트 단위로 나타냅니다.
-   **Service Type** : 데이터 그램이 어떻게 처리되어야 하는가를 정의한 것 입니다.
-   **Total Length** : 헤더와 데이터를 포함하는 IP 데이터그램의 전체 길이를 바이트 단위로 나타냅니다.
-   **identification**(식별) : 발신지 호스트로부터 나온 데이터그램을 유일하게 식별합니다.
-   **flags** : 3비트의 필드로 처음 비트는 사용되지 않고, 두 번째 비트는 do not fragment비트로 1일 경우 단편화를 하면 안됩니다. 세 번째 비트는 more fragment 비트로 1일 경우 마지막 단편(패킷)이 아니라는 것을 알려줍니다.
-   **fragmentation offset**(단편화 옵셋) : 전체 데이터그램 내에서 단편의 상대적 위치를 나타냅니다.
-   **time to live**(수명) : 데이터그램은 인터넷을 통하여 전달되는 동안 제한된 수명을 가지게 되는데 필드 값이 0이 되면 데이터 그램은 폐기 됩니다. 발신지 호스트가 데이터그램을 보낼 때 이 필드에 숫자를 저장하고 데이터그램을 처리하는 각 라우터는 이 필드의 값을 1씩 감소시킵니다.
-   **protocol** : IP 계층의 서비스를 사용하는 상위 계층 프로토콜을 정의 합니다. (TCP, UDP, ICMP...)
-   **checksum**(검사합) : 패킷 전달 중에 발생할 수 있는 오류로부터 패킷을 보호하는 역할을 합니다.
-   **source address** : 발신지의 IP 주소를 정의합니다.
-   **destination address** : 목적지의 IP 주소를 정의합니다.