전송 계층은 네트워크 계층과 응용 계층 사이에 위치합니다.

> **프로세스 대 프로세스 통신**

![1](https://user-images.githubusercontent.com/63203480/130387488-e4f73b1a-b746-4514-89c1-c559e7dcd15f.PNG)

전송 계층의 첫 번째 임무는 프로세스 대 프로세스 통신을 제공하는 것입니다. 프로세스란 **구동 중인 프로그램** 입니다.

네트워크 계층은 호스트 대 호스트 통신에만 책임이 있고, 목적지 컴퓨터에게만 메시지를 전송합니다. 하지만 이것만으로는 전송이 완료되었다고 할 수 없습니다. **메시지를 올바른 프로세스를 통해 처리하여 상위 또는 하위 계층으로 전달**해야 합니다. 이것이 바로 전송 계층 프로토콜이 수행해야 할 책임입니다.

데이터가 전송 될 때 IP 주소와 Port 번호가 담당하는 역할은 다릅니다. IP 주소는 전 세계에 있는 호스트중에 특정 호스트를 정의하기 위하여 사용됩니다. Port 번호는 특정 호스트가 선택된 후에 여러 프로세스 중에서 하나의 프로세스를 정의합니다.

---

> **포트 번호**

![2](https://user-images.githubusercontent.com/63203480/130387519-acb87acd-eb4c-424d-8952-df70586eb828.PNG)
![3](https://user-images.githubusercontent.com/63203480/130387568-05c0848f-8c00-483e-9586-698868601813.png)

통신을 위해서는 클라이언트 IP주소, 클라이언트 포트 주소, 서버 IP 주소, 서버 포트 주소가 있어야 합니다.

클라이언트가 사용할 포트 주소를 설정 한 뒤 서버의 'IP 주소 + 포트 주소' 로 데이터를 전송합니다.  접속이 되면 서버가 원하는 데이터를 클라이언트의 'IP 주소 + 설정한 포트 주소'로 전달해줍니다.

TCP/IP 프로토콜에서 포트 번호는 **0 과 65,535 사이의 정수**입니다.

![4](https://user-images.githubusercontent.com/63203480/130387590-a37660f5-8172-4062-a827-597a3de89894.png)

-   **클라이언트 프로그램**은 수명이 일반적으로 짧기 때문에 임시 포트 번호라고 하는 **임의의 포트번호**로 자신을 지정합니다. 클라이언트, 서버 프로그램이 원활히 동작하기 위해서 임시 포트 번호는 1,023 보다 크게 지정하도록 권장합니다.
-   **서버 프로그램**도 포트 번호로 자신을 정의해야합니다. 하지만 서버 포트 번호는 **임의로 선택할 수 없습니다**. 만약 서버 프로세스를 수행하는 서버 측 컴퓨터가 임의의 번호를 포트번호로 지정한다면 이 서버의 사용을 원하는 클라이언트 측의 프로세스는 서버의 포트 번호를 알 수 없습니다. 따라서 서버는 고정 된 포트 주소를 정의합니다.

TCP/IP 프로토콜에서 포트 번호는 **0 과 65,535번 이고,** 3가지의 범위로 나뉠 수 있습니다.

![5](https://user-images.githubusercontent.com/63203480/130387615-d9b4863e-5d5e-4375-b258-01f776e73f2c.png)

1.  **well-known port**(잘 알려진 포트) : 0 ~ 1023 범위 내의 포트로 서버 측에서 사용하며 루트 권한이 있어야 합니다. 대표적인 프로토콜
2.  registered port(등록된 포트) : 1,024 ~ 49,151 사이의 포트로 루트 권한이 없이 사용이 가능합니다.
3.  dynamic port(동적 포트) : 49,152 ~ 65,535 사이의 포트로 클라이언트 측에서 임시 또는 개인 포트 번호로 사용합니다. 자동으로 할당되기 때문에 미리 알 수가 없습니다.

---

> **TCP **

TCP 는 포트 번호를 이용하여 프로세스 대 프로세스 통신을 제공합니다.

데이터를 안정적으로 순서대로 오류가 발생하지 않도록 하는 프로토콜입니다.

대표적인 well-known 포트는 아래와 같습니다.

-   FTP : 20, 21
-   HTTP : 80
-   SMTP : 25

> **TCP 특징**

**1\. 전 이중 통신(full-duplex)**

\- 데이터를 동시에 양방향으로 전송할 수 있다.

**2\. 연결 지향 서비스**

\- 데이터를 주고 받기 위해서는 아래와 같이 3 단계가 발생합니다.

1.  두 TCP 간에 가상 연결이 설정된다.
2.  양방향으로 데이터가 교환된다.
3.  연결이 종료된다.

\- TCP 세그먼트는 IP 데이터그램으로 캡슐화되어 순서에 어긋나게 전송되거나, 손실 또는 훼손되고, 재전송이 될 수 있습니다.

\- 실제의 물리적인 연결은 없지만 TCP는 스트림 기반의 환경을 제공하여 상대방의 순서에 맞게 바이트를 전달할 책임이 있습니다.

**3\. 신뢰성 서비스**

\- 일정시간동안 ACK 값이 수신을 못할 경우 재전송을 요청한다 - **시간초과**

\- ACK값이 중복으로 올 경우 패킷 이상을 감지하고 재전송을 요청한다 - **중복**

**4\. 흐름 제어**

\- **수신 되는 데이터의 양**을 조절합니다.

**5\. 혼잡 제어**

- **네크워크 망 내에 데이터의 양**이 넘치지 않도록 조절합니다.

> **TCP 패킷 구조**

![6](https://user-images.githubusercontent.com/63203480/130387628-dafae052-b238-4170-8dee-0e88105f6939.png)

- Source Port : 패킷의 출발지 포트 번호를 가리키며 0 ~ 65535 값 중 하나입니다.

- Destination Port : 패킷의 목적지 포트 번호입니다.

- Sequence Number : 패킷의 순서 값입니다.

- Ack Number : 통신 상대의 패킷 순서 값입니다.

- Data Offset : TCP 패킷 헤더의 길이 나타내는데, 32bits가 몇 행인지를 가리킵니다. 최소 값은 5 입니다.

- Reserved : 필요 시 사용하기위해 남겨둔 공간입니다.

- Control Bits : TCP 패킷의 종류와 특성을 가리킵니다.

-   URG : Urgent Pointer 가 유효한지 알려줍니다. Urgent Pointer가 유효하다면 데이터를 우선 처리해야 합니다.
-   ACK : 이전에 SYN 동작을 확인했다는 것을 알려줍니다.
-   PSH : 수신 된 데이터를 즉시 상위 계층인 어플리케이션 계층에 전달해야 한다고 알려줍니다.
-   RST : 문제가 생겨 접속이 강제 종료되었다고 알려줍니다.
-   SYN : 연결 설정을 요구합니다. 수신 측과 송신 측이 보낸 최초의 패킷에만 플래그가 설정되어야 합니다.
-   FIN : 더 이상 전송할 데이터가 없기에 연결 종료 의사를 표시합니다.

- Window : TCP 에서는 흐름 제어 시 슬라이딩 윈도우와 혼잡 위도우 방법을 사용합니다.

-   슬라이딩 윈도우: 데이터를 한 번에 처리할 수 있는 버퍼의 용량을 의미하는 윈도우의 개념을 사용합니다. 송신에 대한 확인 메시지를 수신하기 전에 다른 세그먼트를 전송할 수 있도록 해줍니다.
-   혼잡 윈도우: 네트워크 혼잡 문제를 해결하기 위해 송신 시스템이 사용하는 방법입니다. 네트워크의 혼잡이 발견되면 데이터의 양을 조절하여 줄이고, 혼잡이 줄어들면 원래대로 늘린다.

\- Checksum : 데이터 오류 검출을 위한 값입니다.

\- Urgent Pointer : 현재 전송되는 데이터와 관계없는 TCP 데이터를 보내 우선 처리하도록 하는 값 입니다.

\- Options : 옵션의 종류와 길이, 데이터를 저장합니다.

\- Padding : 옵션이 32bits가 되지 않는다면 나머지 비트는 0으로 채우는 역할입니다.

\- Data : 전송하고자 하는 데이터를 저장합니다.

> **TCP 연결과 해제**

-   TCP Connection(3-handshake)

![7](https://user-images.githubusercontent.com/63203480/130387690-e985f2b8-cd82-4870-a31d-9afa7fe6afdc.png)

1.  클라이언트가 SYN 를 서버에게 보내고 SYN Sent 상태로 있는다.
2.  SYN Received 상태로 바꾼 후 SYN + ACK 를 클라이언트에게 보냅니다.
3.  응답을 받은 클라이언트는 서버에게 ACK를 보낸 후 Established 상태로 변경합니다.

-   TCP Disconnection(4-handshake)

![8](https://user-images.githubusercontent.com/63203480/130387698-bb10e977-24f2-4f5e-af51-63ce4ee8b80d.png)

1.  클라이언트는 서버에게 FIN 을 보낸 후 Close Wait 상태로 변경합니다.
2.  서버는 응답 ACK 를 클라이언트에게 보냅니다.
3.  서버가 종료 프로세스를 진행한 뒤 FIN 을 클라이언트에게 보냅니다.
4.  클라이언트는 응답 ACK 를 서버에게 보낸 뒤 Closed 상태로 변경합니다.

---

> **UDP**

실시간 통신(VoIP, 동영상 스트리밍)처럼 **데이터의 고속 전송**이 필요 시 사용하는 프로토콜입니다.

상대방이 보낸 응답을 확인하지 않기 때문에 **네트워크에 부하를 주지 않습니다**.

데이터 자체의 신뢰성이 없어 수신한 데이터의 **무결성을 보장 받지 못합니다**.

실시간 처리가 중요한 게임이나 스트리밍에서는 UDP를 사용하긴 하지만 데이터의 신뢰성이 중요하기 때문에 **어플리케이션 계층에서 혼잡제어, 오류 제어 등 문제를 보완**합니다.

> **UDP 특징**

1\. 비연결형 서비스

2\. 네트워크 부하 감소

3\. 비신뢰성 : 혼잡, 오류 제어의 미제공

4\. 전송된 데이터의 일부가 손실

5\. 속도가 빠름

> **UDP 패킷 구조**

![9](https://user-images.githubusercontent.com/63203480/130387709-7bad46f4-ef8b-41ba-a179-4424e17d1190.png)

Source Port : 패킷의 출발지 포트 번호로 0 ~ 65535 값 중 하나입니다.

Destination Port : 패킷의 목적지 포트 번호입니다.

Length : UDP 헤더와 데이터 필드를 포함한 전체 패킷의 길이입니다.

Checksum : 데이터 오류 검출을 위한 값입니다.

Data : 전송하고자 하는 데이터를 저장합니다.

---

> **TCP 와 UDP 의 차이점**

- TCP **vs** UDP

1.  연결형 **vs** 비연결형
2.  신뢰성 **vs** 비신뢰성
3.  1대 1 통신 **vs** 1대 1, 1대 N, N대 M 통신
4.  Byte 스트림 **vs** Message 스트림
5.  제어 **vs** 제어 지원 X
6.  패킷: Segment **vs** Datagram
7.  상대적으로 느림 **vs** 빠름