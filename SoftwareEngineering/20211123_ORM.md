# ORM(Object-relatinal mapping)

![1](https://user-images.githubusercontent.com/63203480/142977956-54b04f52-b790-4bc8-b37c-d96f02c99afb.png)

ORM 이란 객체(클래스) 와 관계형 데이터 베이스의 데이터를 자동으로 매핑(연결) 해주는 역할을 합니다.   
대표적으로 Flask - SQLAlchemy, Django - 내장 ORM, Node.js - Sequalize, NestJS - TypeORM , java - Hybernate, JPA 등이 있습니다. 

## ORM 장/단점
### 장점
#### 1. 객체지향적인 코드
- 직관적이고, 비즈니스 로직에 더 집중할 수 있도록 도와준다.
- SQL 문을 사용하면서 필요한 선언문, 할당, 종료 같은 부수적인 코드가 줄어든다.
- 코드를 별도로 작성하기 때문에 코드의 가독성을 올려준다.
- SQL 의 절차적이고, 순차적인 접근이 아닌, 객체 지향적인 접근으로 생산성이 증가한다.

#### 2. 재사용, 유지보수, 리팩토링의 용이성
- ORM 을 통해 작성한 객체를 재활용할 수 있다는 측면에서 재사용 및 유지보수가 편리하다.
- 매핑정보가 명확하기 때문에, ERD 보는 것에 대한 의존도를 낮출 수 있다.

#### 3. DBMS 에 대한 종속성이 줄어든다.
- 객체 간의 관계를 바탕으로 SQL 문을 자동으로 생성하고, 객체의 자료형 타입까지 사용할 수 있기 때문에 RDBMS 의 데이터 구조와 객체지향 모델 사이의 간격을 좁힐 수 있다.
- 객체에만 집중하면 되기 때문에 DBMS 를 교체하는 큰 작업에도 리스크가 적고 드는 시간도 줄어든다.
- 개발자가 어플리케이션과 데이터베이스의 중간에서 변환 작업을 직접하지 않아도 된다.

### 단점
#### 1. ORM 이 모든것을 해결해주지는 못한다.
- 프로젝트의 복잡성이 커질 수록 난이도 높아지고, 설계가 잘못 이뤄졌을 경우에는 속도 저하 및 일관성이 무너지는 문제가 생길 수 있다.
- 복잡한 쿼리일 경우 오히여 SQL 문의 사용이 직관적이면서 효율적일 수 있다.

#### 2. 프로시저가 많은 시스템에서는 ORM 의 객체 지향적인 장점을 활용하기 어렵다.
- 이미 프로시저가 많은 시스템에서는 다시 객체로 바꾸는 작업이 필요하며, 그 과정에서 생산성 저하나 리스크가 많이 발생할 수 있다.
    - 프로시저: SQL 에서 제공하는 프로그래밍 기능으로, 쿼리문을 하나의 메서드 형식으로 만들고 어떤한 동작을 일괄처리 하는 용도
    

## ORM 사용 예시
### Query
```mysql
select name, age from User where id = 1;
```

### TypeORM
```typescript
const [userPasswordResult] = await this.usersRepository.find({
  select: ['name', 'age'],
  where: { id: 1 },
});
```