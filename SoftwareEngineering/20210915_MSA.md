MSA는 소프트웨어 개발 기법 중 하나로, 어플리케이션 단위를 목적으로 나누는 것이 핵심인 방법입니다.

MSA를 알기 전에는 Monolithic 아키텍처를 알아야합니다.

> **Monilithic 아키텍처**

![1](https://user-images.githubusercontent.com/63203480/133432711-b2c2fa5c-145b-462b-ad61-879bdfeeea53.png)

MSA 아키텍처 전의 소프트웨어 개발 방식으로 **하나의 거대한 백엔드 어플리케이션이 모든 것을 처리하는 방법**입니다.

예를들면 위의 사진 처럼 하나의 백엔드 어플리케이션이 유저 생성, 결제, 홈페이지 등 모든 것을 처리합니다.

즉, 하나의 OS 위에 여러가지 어플리케이션들을 개발하고 하나의 DB를 연동하여 관리하는 방법으로 프로젝트 진행 시 우리가 자주 사용하는 방법일 겁니다.

이 방식은 하나의 백엔드 어플리케이션이 모든 기능을 담고 있기 때문에 관리하기 용이하고 배포하는 과정부터 모든 과정이 어렵지 않습니다.

하지만 대용량 어플리케이션을 구축하거나 끊임없이 수정이 필요한 프로그램을 만들었다고 가정을 해보면 어플리케이션 내의 각 기능들이 모두 구조적으로 결합되어있기 때문에 **하나의 기능이 문제를 일으킨다면 다른 기능들이 연쇄적으로 문제**를 일으킬 수도 있습니다. 또한 하나의 기능을 수정하여 **배포를 진행할 때, 모든 기능을 재배포** 해야하는 문제점이 발생합니다.

그리고 **서버가 수직적인 확장만 가능(탄력적이지 못하다)** 하게 됩니다. 만약 서버를 업그레이드해야되는 경우가 있다면 메모리, 저장용량, 기가바이트, 파워 등을 전부 업그레이드해야됩니다. 갑자기 트래픽이 급증하는 일이 발생할 경우 이를 대응할 수 없고, 서버를 업그레이드 했는데 유저가 감소한다면 업그레이드를 한 이유가 없어집니다.

이런 문제때문에 모노리틱 서비스 아키텍처에서 마이크로 서비스 아키텍처로 많이 바뀌고 있다고 합니다.

> **마이크로 서비스 아키텍처**

![2](https://user-images.githubusercontent.com/63203480/133432665-d4c6ec4e-83a3-4aba-910f-00ff921c57f8.PNG)

MSA는 각 기능들이 작고, 독립적인 서비스로 세분화되어 있는 방식입니다. 한꺼번에 비즈니스 로직을 구성하는 Monolithic 방식과는 다르게 **기능(목적)별로 컴포넌트를 나누고 조합**할 수 있도록 구축하고 운영하고 배포하기 때문에 **서로 의존성이 없습니다**. 그리고 각 컴포넌트는 API를 통해 다른 기능들과 통신을 합니다.

따라서 서비스들은 **각자 다른 서버**에서 돌아갈 수도 있고 **프로그래밍 언어가 달라도** 됩니다. 따라서 기능 별로 효율적인 언어나 프레임웍을 선택하여 개발이 가능하여 수많은 개발자들이 일하는 큰 회사에서 도입하면 효과적입니다.  또한 **일부 기능이 에러가 발생해도 전체에 영향을 미치지 않게** 됩니다. 예를 들면 위의 사진의 Search 기능에 에러가 발생해도 Email이나 Payment 기능에는 영향을 끼치지 않습니다.

![3](https://user-images.githubusercontent.com/63203480/133432696-3e5ef3e8-9c8d-4f15-9032-1a309aad47a2.png)

MSA에서 각 기능들은 **컨테이너라는 단위로 관리**됩니다.

컨테이너는 가자의 OS를 가지고 있고, 그에 연동되는 각자의 DB를 가질 수 있습니다. 완전히 독립적인 개체로 존재하여 각 컨테이너간의 간섭을 최소화합니다. 기능들을 연동하기 위해서는 컨테이너만의 네트워크를 따로 가지며 각자 하나의 서버처럼 움직이기 때문에 네트워크 그룹단으로 통신을 하며 데이터를 주고 받습니다.

MSA는 Monilithic 아키텍처와는 다르게 **수평적 확장**이 가능합니다. 더 많은 기계를 사는 것이 아니라, 필요에 따라 작은 기계들을 사서 만드는 것입니다. 예를 들면 검색을 하는 유저가 많아졌다면 검색기능을 하는 기계만 늘리면 됩니다. 즉, **다른 기능들과는 독립적으로 확장**이 가능합니다(=> 필요한 기능만 확장하면 된다). 따라서 서비스 별로 개발팀이 꾸려질 경우 다른 팀과 의존없이 팀 내에서 피드백을 빠르게 할 수 있고, 비교적 유연하게 운영이 가능합니다.

하지만 MSA도 좋은 점만 가지고 있는 것은 아닙니다. MSA는 기능 별로 호출할 때 **API로 통신하기 때문에 속도가 느립니다**. 그리고 기능 별로 **통신에 맞는 데이터로 맞추는 과정도 필요**합니다.  Monilithic 은 하나의 OS 내에서 진행되기 때문에 MSA보다 속도 면에서 훨씬 빠를 것입니다. 또한 MSA는 **DB가 개별적으로 운영되기 때문에 트랜잭션으로 묶기 힘든 점**도 있습니다. 넷플릭스 같은 경우는 MSA로 바꾸는데만 5년이라는 시간이 걸렸다고 합니다.

따라서 체계적으로 준비가 되어있지 않다면 MSA로 인해 프로젝트 성능이 안 좋아질수도 있습니다. 그렇기에 프로젝트의 목적, 현재 상황에 맞는 아키텍처 방식이 무엇인지 설계할 때부터 잘 고민하여 선택하는 것이 중요합니다.