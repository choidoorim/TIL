# 12-1. 동기화란

- 동시에 협력하며 실행하는 프로세스들은 실행 순서와 자원의 일관성을 보장해야 하기에 반드시 동기화되어야 한다.

## 동기화의 의미

- 공동의 목표를 위해 서로 협력하는 프로세스들은 서로 데이터를 주고 받으면서 실행한다. 협력하는 프로세스들은 아무렇게나 동시에 실행되면 안되고, 올바른 실행을 위해서 동기화가 필수다.
- 프로세스 동기화란 프로세스들 사이의 수행시기를 맞추는 것이다.
    - 수행시기란 실행 순서 제어와 상호 배제가 있다. 실행 순서 제어란 **프로세스를 올바른 순서대로 실행하는 것**이며 상호 배제란 **동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하는 것**이다.
- 동기화에는 실행 순서 제어를 위한 동기화가 있고, 상호 배제를 위한 동기화가 있다.

### 실행 순서 제어를 위한 동기화

- 동시에 실행되는 프로세스를 올바른 순서대로 실행하는 것이 실행 순서 제어를 위한 동기화이다.
- Writer 라는 프로세스와 Reader 라는 프로세스가 동시에 있을 때 Reader 라는 프로세스는 Writer 프로세스가 실행이 끝나야 비로소 실행이 가능하다. Writer 프로세스가 Book.txt 에 값을 저장하기도 전에 Reader 프로세스가 Book.txt 를 읽는 것은 올바른 실행 순서가 아니다. 즉, Reader 프로세스는 Book.txt 파일 안에 값이 존재한다는 조건이 만족되어야만 실행이 가능하다.

### 상호 배제를 위한 동기화

- 공유가 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘이다. 동시에 접근해서는 안 되는 자원에 동시에 접근하지 못하게 하는 것이 상호배제를 위한 동기화이다.
- 계좌에 10만원이 있다고 가정했을 때, 프로세스A 는 2 만원을 계좌에 추가하고, 프로세스B 는 5만원을 계좌에 추가한다고 가정해보자. 프로세스A 와 프로세스B 가 동시에 실행하면 당연히 결과는 17만원이여야 하지만 동기화가 제대로 이뤄지지 않은 경우 결과가 15만원이라는 엉뚱한 결과가 나올 수 있다. 이런 결과가 나온 이유는 A 와 B 가 잔액이라는 데이터를 동시에 사용하는데 A 가 끝나기도 전에 B 가 잔액을 읽어 버렸기 때문에 엉뚱한 결과가 나온 것이다.

## 생산자와 소비자 문제

- 생산자란 물건을 계속해서 생산하는 프로세스이고, 소비자는 물건을 계속해서 소비하는 프로세스이다.
- 생산자와 소비자가 총합이라는 데이터를 공유하고 있다. 그리고 생산자는 버퍼에 물건을 넣은 후 물건의 총합에 해당하는 변수를 1 증가시키고, 소비자는 버퍼에 물건을 빼낸 후 물건의 총합에 해당하는 변수를 1 감소시킨다.

    ```
    총합 = 10
    
    생산자() {
    	버퍼에 데이터 삽입
    	총합 변수 1 증가
    }
    
    소비자() {
    	버퍼에 데이터 빼내기
    	총합 변수 1 감소
    }
    ```

  만약 위 로직에서 생산자를 100,000 번, 소비자를 100,000 번 동시에 실행한다면 총합 변수의 값은 실행 결과를 10에 머물러 있기를 기대하지만 총합이 10이 아닌 다른 수가 되거나 실행 중 오류가 발생할 수 있다.

  이런 문제가 발생하는 이유는 생산자 프로세스와 소비자 프로세스가 제대로 동기화되지 않아서 발생한 문제이다.


## 공유 자원(shared resource)과 임계 구역(critical section)

- 동시에 실행되는 프로세스들이 공동의 자원을 두고 작업하는데, 이러한 자원을 공유 자원이라고 한다. 공유 자원은 전역 변수, 파일, 입출력 장치 등이 될 수 있다.
- **동시 실행하면 문제가 발생하는 자원에 접근하는 코드 영역을 임계 구역**이라고 한다. 2 개 이상의 프로세스가 임계 구역에  접근하려고 하면 대기 중인 프로세스가 생긴다.
- 임계 구역에는 여러 프로세스가 접근할 수 없지만, 잘못된 오류로 인해 **여러 프로세스가 동시에 임계 구역의 코드를 실행하여 문제가 발생하는 경우**가 있다. 그리고 이를 **레이스 컨디션**이라고 한다.
- 고급 언어는 실행과정에서 저급 언어로 변환되어 실행되는데, 여러 줄의 저급 언어로 변환된 고급 언어 한 줄을 실행하는 과정에서 문맥 교환이 일어날 수 있기 때문에 레이스 컨디션이 발생한다.
- 운영체제는 임계 구역의 이러한 문제를 “상호 배제, 진행, 유한 대기”라는 3 가지 원칙을 통해 해결한다.
    - 상호 배제: 하나의 프로세스가 임계구역에 진입했다면 다른 프로세스는 임계구역에 접근할 수 없다.
    - 진행(progress): 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고 싶은 프로세스는 진입할 수 있어야 한다.
    - 유한 대기(bounded waiting): 임계 구역에 들어오고 싶은 프로세스가 있다면 무한정 대기해서는 안된다. 즉, 언젠가는 임계 구역에 진입할 수 있어야 한다.
