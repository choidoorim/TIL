# 11-2. CPU 스케줄링 알고리즘

## 선입 선처리 스케줄링(FCFS 스케줄링)

![Untitled](https://github.com/choidoorim/programing-books/assets/63203480/1c513585-b7a3-4de8-93d2-7416c23f8ac7)

- 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식이다.
- 공정하지만, 경우에 따라 CPU 를 길게 사용하는 프로세스들이 있다면 다른 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 단점이 있다. 그리고 이런 단점을 호위 효과(convey effect)라고 한다.

## 최단 작업 우선 스케줄링(Shortest Job First 스케줄링)

![Untitled](https://github.com/choidoorim/programing-books/assets/63203480/4cc5884c-3e0a-4e23-b5de-6eaef9d2f3cf)

- 준비 큐에 삽입된 프로세스들 중에 CPU 이용 시간이 가장 짧은 프로세스부터 실행하는 스케줄링 방식이다.
- 비선점 스케줄링 알고리즘으로 분류되지만, 선점형으로도 구현이 가능하다.

## 라운드 로빈 스케줄링

![Untitled 1](https://github.com/choidoorim/programing-books/assets/63203480/7bbf95f3-193a-4ce1-8ba7-54a4670b0787)

- 선입 선처리 스케줄링이 타임 슬라이스라는 개념이 더해진 스케줄링 방식이다. 즉, 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU 를 이용하는 선점형 스케줄링이다.
    - 타임 슬라이스: 각 프로세스가 CPU 를 사용할 수 있는 정해진 시간을 의미
- 정해진 시간을 모두 사용했음에도 프로세스가 완료되지 않았다면 **다시 큐의 맨 뒤에 삽입**된다.
- 라운드 로빈 스케줄의 핵심은 **타임 슬라이스 크기를 어느 정도로 설정하는가**이다. 타임슬라이스 크기가 지나치게 크다면 선입 선처리 스케쥴링과 다를 것이 없고, 타임슬라이스 크기가 지나치게 작다면 문맥교환에 발생하는 비용이 커져서 CPU 는 프로세스를 처리하는 일보다 프로세스를 전환하는데 자원을 더 많이 사용하게 된다.

## 최소 잔여 시간 우선 스케줄링(Shortest Remaining Time 스케줄링)

![Untitled 2](https://github.com/choidoorim/programing-books/assets/63203480/cc4475ca-ae8e-4d56-8c93-bb92e2b2e03b)

- 최단 작업 **우선 스케줄링과 라운드로빈 스케줄링을 합친 스케줄링 방식**이다.
- 프로세스들은 정해진 타임 슬라이스 크기만큼 CPU 를 사용하되, CPU 를 사용할 다음 프로세스로는 **남아있는 작업 시간이 가장 적은 프로세스가 선택**된다.

## 우선순위 스케줄링(Priority 스케줄링)

- 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 알고리즘이다. 최단 작업 우선 스케줄링, 최소 잔여 시간 우선 스케줄링 알고리즘 모두 넓은 의미에서 우선순위 스케줄링의 일종으로 볼 수 있다.
- 준비 큐에 먼저 삽입되었지만, 우선 순위에 밀려 프로세스의 실행이 계속해서 밀릴 수도 있다. 그리고 이런 현상을 기아(starvation) 현상이라고 한다.
- 기아 현상을 방지하기 위한 대표적인 기법으로 에이징 기법이 있다. 에이징 기법이란 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식이다. 우선순위가 점차 높아지기 때문에 우선순위가 낮아 마냥 기다리기만 하는 프로세스가 없어진다.

## 다단계 큐 스케줄링(Multilevel Queue 스케줄링)

![Untitled 1](https://github.com/choidoorim/programing-books/assets/63203480/1e99a347-e586-4522-860e-3c2ffa58eed0)

- 우선순위 스케줄링의 발전된 형태로 우선 순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식이다.
- 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선순위가 가장 높은 큐가 비어있으면 그 다음 우선순위 큐에 있는 프로세스들을 처리한다.
- 큐를 여러 개 두면서 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해진다.

## 다단계 피드백 큐 스케줄링(Multilevel Feedback Queue 스케줄링)

- 다단계 큐 스케줄링은 프로세스들이 큐 사이를 이동할 수 없다. 그렇기 때문에 우선순위가 높은 프로세스가 계속해서 들어온다면 우선순위가 낮은 프로세스는 계속 연기될 여지가 있다는 단점이 있다.
- 다단계 피드백 큐 스케줄링은 프로세스들이 큐 사이를 이동할 수 있다는 특징이 있다.
- 새로 준비 상태가 된 프로세스가 있다면 우선순위가 가장 높은 우선순위 큐에 삽입되고 일정 시간(타입슬라이스) 동안 실행된다. 만약 프로세스가 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행된다. 즉, 오래 사용해야 하는 프로세스는 점차 우선순위가 낮아지고 CPU 를 비교적 적게 사용하는 입출력 프로세스들은 자연스럽게 우선순위가 높은 큐에서 실행이 끝난다.
- 다단계 피드백 큐 스케줄링은 프로세스들이 큐 사이를 이동할 수 있는 방식이기 때문에 낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면 점차 우선순위를 높은 큐로 이동시키는 에이징 기법을 적용하여 기아 현상을 예방할 수 있다.
- 프로세스의 **CPU 이용시간이 길면 낮은 우선순위 큐로 이동시키고, 낮은 우선순위 큐에서 너무 오래 기다린다면 높은 우선순위 큐로 이동시킬 수 있는 알고리즘**이다.
- 구현이 복잡하고 어렵지만 가장 일반적인 CPU 스케줄링 알고리즘이다.
