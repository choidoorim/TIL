## 연산 코드와 오퍼랜드
- **연산코드와 오퍼랜드로 구성**되어 있다.
- **명령어가 수행할 연산**을 연산 코드라고 하고, **연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치**를 오퍼랜드라고 한다. 연산 코드는 연산자, 오퍼랜드는 피연산자 라고 한다.
- 연산코드가 담기는 영역을 연산 코드 필드, 오퍼랜드가 담기는 영역을 오퍼랜드 필드라고 한다.
- 기계어와 어셈블리어도 명령어이기 때문에 연산 코드와 오퍼랜드로 구성되어 있다.
```
연산코드  오퍼랜드
push    rbp
mov     rbp, rsp
mov     DWORD PTR [rbp-4], 1
...
```

### 오퍼랜드 
- 오퍼랜드 필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있다. 대부분은 데이터를 직접 명시하기 보다는 데이터가 저장된 위치인 메모리 주소나 레지스터 이름이 담긴다. 그래서 **오퍼랜드 필드를 주소 필드**라고도 부른다.
- 오퍼랜드는 명령어 안에 여러개 있을 수 있다. 
- 오퍼랜드가 하나도 없는 명령어는 0-주소 명령어, 오퍼랜드가 n 개인 명령어는 n-주소 명령어라고 한다.

### 연산코드
- 연산코드의 종류는 많지만, 가장 기본적인 연산코드 유형은 "**데이터 전송, 산술/논리 연산, 제어 흐름 변경, 입출력 제어**" 4 가지로 나눌 수 있다.
- 데이터 전송: MOVE, STORE, LOAD(FETCH), PUSH, POP
- 산술/논리 연산: ADD, SUBTRACT, MULTIPLY, DIVIDE, INCREMENT, DECREMENT, AND, OR, NOT, COMPARE
- 제어 흐름 변경: JUMP, CONDITIONAL JUMP, HALT, CALL, RETURN
- 입출력제어: READ, WRITE, START IO, TEST IO

## 주소 지정 방식
- 오퍼랜드 필드에 메모리나 레지스터의 주소를 담는 이유는 명령어의 길이 때문이다. 명령어가 n 비트로 구성되어 있고, 이 중에 연산 코드 필드가 m 비트라고 가정해보자. 1-주소 명령어는 오퍼랜드 필드에 가장 많은 공간을 할당할 수 있지만, 오퍼랜드 필드의 길이는 연산 코드만큼의 길이를 뺀 n-m 비트이다. 예를 들면 명령어의 크기가 16비트인데, 연산 코드 필드가 4비트인 3-주소 명령어에서는 오퍼랜드 필드당 4비트(12bit/3bit) 정도로 2^4 개의 정보만 표현할 수 있다. **오퍼랜드 필드 안에 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다**. 
- 한 주소에 16비트를 저장할 수 있는 메모리가 있다면 메모리 안에 데이터를 저장하고, 오퍼랜드 필드 안에 주소를 명시한다면 표현할 수 있는 정보의 가짓수가 2^16 로 확 커지게 된다.
- **연산의 대상이 되는 데이터가 저장된 위치를 유효 주소**라고 한다. 
- 연산에 사용할 데이터의 위치를 찾는 방법을 주소 지정 방식이라고 한다.

### 1. 즉시 주소 지정 방식
- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식이다. 
- 표현할 수 있는 데이터의 크기는 작지만, 주소를 찾는 과정이 없기 때문에 다른 주소 지정 방식들 보다 빠르다. 

### 2. 직접 주소 지정 방식
- 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식이다. 
- 표현할 수 있는 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한이 생길 수 있다. 
- 메모리 주소가 변경될 때 마다 모든 해당 주소를 참조하는 명령어를 모두 수정해야 하는 번거로움이 있다.

### 3. 간접 주소 지정 방식
- 유효 주소의 주소를 오퍼랜드 필드에 명시한다. 
- 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 더 넓어졌다. 
- 두 번의 메모리 접근이 필요하기 때문에 상대적으로 더 느리다.
- 유효 주소의 주소인 포인터를 통해 데이터를 참조하기 때문에, 포인터가 가리키는 주소만 변경하면 되기 때문에 수정 작업이 상대적으로 쉽다.

### 4. 레지스터 주소 지정 방식
- 직접 주소 지정 방식과 비슷하게 **데이터를 저장한 레지스터**를 오퍼랜드 필드에 직접 명시하는 방법이다. 
- CPU 외부의 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르다. 
- 표현할 수 있는 레지스터 크기에 제한이 있다는 단점이 있다.

### 5. 레지스터 간접 주소 지정 방식
- 연산에 사용될 데이터는 메모리에 저장하고, 데이터의 주소(유효주소)를 레지스터에 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법이다. 
- 간접 주소 지정 방식과 비슷하지만 메모리에 접근하는 횟수가 1번으로 줄어들고, 메모리에 접근하는 것보다 레지스터에 접근하는 것이 더 빠르기 때문에 간접 주소 지정 방식보다 빠르다.

![이름 없는 노트북-7](https://user-images.githubusercontent.com/63203480/232787115-ef27bd87-ca8a-48ba-ae8c-8e9cf4e7011b.jpg)


## 스택과 큐
- 스택은 한쪽 끝이 막혀 있는 통과 같은 저장 공간이다. 나중에 저장한 데이터를 가장 먼저 빼는 Last In First Out(LIFO) 자료구조라고 부른다.
- 큐는 양쪽이 뚫려 있는 통과 같은 저장 공간을 큐라고 한다. First In First Out(FIFO) 자료 구조라고도 부른다.
