# 5-2. 명령어 병렬 처리 기법
- 빠른 CPU 를 만들기 위해서는 높은 클럭 속도와 멀티 코어, 멀티 스레드를 지원하는 CPU 도 중요하지만, 
CPU 를 쉬지 않고 시간을 알뜰하게 쓰며 작동하게 만드는 것도 중요하다.
- 명령어 병렬 처리 기법은 명령어를 동시에 처리하여 CPU 를 쉬지 않고 작동시키는 기법이다.

## 명령어 파이프라인(Instruction Pipeline)
- 클럭 단위로 명령어 처리과정은 "명령어 인출 -> 명령어 해석 -> 명령어 실행 (-> 메모리 접근) ->결과 저장" 이다. 
  만약 처리 과정 중 **단계가 겹치지 않는다면 CPU 는 각 단계를 동시에 실행**할 수 있다. 따라서 명령어를 겹쳐서 수행한다면 명령어를 하나하나 실행하는 것보다 훨씬 더 효율적으로 처리할 수 있을 것이다.

  ![pipelining](https://github.com/choidoorim/TIL/assets/63203480/a841977c-b7e7-4d12-9d9e-514f81efbbfa)

- 명령어들을 명령어 파이프라인에 넣고 동시에 처리하는 기법을 명령어 파이프라이닝이라고 한다.
- 파이프라이닝이 높은 성능을 제공하지만, 특정 상황에서는 성능 향상에 실패하는 경우도 있는데, 이것을 파이프라인 위험(Pipeline Hazard)이라고 한다.
그리고 데이터 위험, 제어 위험, 구조적 위험이 있다.

### 파이프라인 위험 - 데이터 위험
- 명령어 간 데이터 의존성에 의해 발생한다.
  ```
  명령어1: R1 <- R2 + R3
  명령어2: R4 <- R1 + R5
  ```
  위와 같은 명령어는 `명령어1`이 수행되어야 `명령어2`가 수행될 수 있다. R1 에 결괏값이 저장되기 전에 R1 값을 읽어들이기 때문에 원치 않은 R1 값으로 명령어 2를 수행하게 된다.
  즉, 명령어2는 명령어1의 데이터에 의존적이다.
- 데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 하면 파이프라인이 제대로 작동하지 않는 것을 "데이터 위험"이라고 한다. 

### 파이프라인 위험 - 제어 위험
- 프로그램 카운터는 현재 실행 중인 명령어의 다음 주소로 갱신되는데, 프로그램 카운터 값의 갑작스러운 변화가 생겨서
명령어 파이프라인에 미리 가지고 와서 처리 중이였던 명령어는 아무 쓸모가 없게 된다. 그리고 이것을 제어 위험이라고 한다.
- 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술인 "분기 예측(branch prediction)" 은 제어 위험을 위해 사용하는 기술 중 하나이다.

### 파이프라인 위험 - 구조적 위험 = 자원 위험
- 서로 다른 명령어가 동시에 같은 CPU 부품(ALU, 레지스터 등)을 사용하려고 할 때 발생한다.

## 슈퍼스칼라
- 단일 파이프라인으로도 파이프라이닝이 가능하지만, 근래 CPU 는 여러 개의 파이프라인을 이용한다. CPU 내부에 여러 개의 명령어 파이프라인을 포함하는 구조를 슈퍼스칼라라고 한다.
- 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU 를 슈퍼스칼라 프로세서, 슈퍼스칼라 CPU 라고 한다.
- 슈퍼스칼라 프로세서는 매 클럭 주기마다 여러 명령어를 인출, 실행할 수 있다. 그렇기 때문에 이론적으로는 파이프라인 개수에 비례하여 프로그램 처리 속도가 빨라지지만, 파이프라인을 사용할 때 데이터/제어/구조적 위험이 있기 때문에 실제로는 그렇지 못하다. 따라서 슈퍼스칼라 CPU 를 설계할 때는 고도로 설계되어야 한다.

## 비순차적 명령어 처리(OOOE: Out Of Order Execution)
- 파이프라인의 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 기법을 비순차적 명령어 처리라고 한다.
근래 CPU 성능 향상에 큰 기여를 한 기법으로, 합법적 새치기라고 하기도 한다.
- 기존 파이프라이닝, 슈퍼스칼라처럼 순차적으로 명령어를 처리하다보면 예상치못한 상황에서 명령어 파이프라인은 멈춰버리게 된다. 아래와 같은 명령어 소스 코드가 있다고 해보자.

    ```
    // 메모리 N 번지에 M 을 저장하라 M(N) <- M
    1. M(100) <- 1
    2. M(101) <- 2
    3. M(102) <- M(100) + M(101)
    4. M(150) <- 1
    5. M(151) <- 2
    6. M(152) <- 3
    ```

    3번 명령어를 실행하기 위해서는 `M(100), M(101)` 값이 필요하다. 순차적으로 실행할 때는 2번 명령이 끝나기 전까지는 3, 4, 5, 6번 명령이 대기하게 된다. 명령어들 중에 서로 데이터의 의존성이 전혀 없고, 순서를 바꿔 처리해도 결과에 영향을 미치지 않는 명령어들이 있다.

    ```
    1. M(100) <- 1
    2. M(101) <- 2
    4. M(150) <- 1
    5. M(151) <- 2
    6. M(152) <- 3
    3. M(102) <- M(100) + M(101)
    ```

    그렇기 때문에 위처럼 순서를 바꿔도 상관없는 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법을 비순차적 명령어 처리 기법이라고 한다.
- 비순차적 명령어 처리가 가능한 CPU 는 명령어들 간의 데이터 의존성이 있는지, 순서를 바꿔 실행할 수 있는 명령어는 어떤 것인지 판단할 수 있어야 한다.
