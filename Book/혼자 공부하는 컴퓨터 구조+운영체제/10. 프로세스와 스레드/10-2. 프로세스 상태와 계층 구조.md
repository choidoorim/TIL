# 10-2. 프로세스 상태와 계층 구조

## 프로세스 상태

- 하나의 프로세스는 여러 상태를 가진다. 그리고 운영체제는 프로세스의 상태를 PCB 를 통해 인식하고 관리한다.

![Untitled](https://github.com/choidoorim/programing-books/assets/63203480/ad66d800-a843-408e-bca5-3297eadd4e35)

### 생성 상태(new)

- 프로세스가 생성 중인 상태이다.
- 메모리에 적재되어 PCB 를 할당받은 상태이다.
- 생성 상태가 되어 실행할 준비가 완료된 프로세스는 곧바로 실행되지 않고 **준비 상태가 되어 CPU 의 할당을 기다린다**.

### 준비 상태(ready)

- 프로세스가 CPU 를 할당받을 수 있는 상태이지만, **아직 자신의 차례가 아니기에 기다리고 있는 상태**이다.
- 자신의 차례가 되면 CPU 를 할당받아 실행 상태가 된다.
- 준비상태가 실행상태로 전환되는 것을 디스패치(dispatch) 라고 한다.

### 실행 상태(running)

- CPU 를 할당받아 실행 중인 상태를 의미한다.
- 할당된 일정 시간 동안만 CPU 를 사용할 수 있다. 타이머 인터럽트가 발생해서 일정 시간이 지난다면 다시 준비 상태가 되고, 입출력 작업이나 특정 이벤트가 일어나기를 기다려야 한다면 대기 상태가 된다.
- 프로세스가 대기상태가 되는 대부분의 이유는 입출력 작업때문이다.

### 대기 상태(waiting)

- 프로세스는 실행 도중에 입출력 장치를 사용하는 경우가 있다. **입출력 작업은 CPU 에 비해 처리 속도가 느리기 때문에**, 입출력 작업을 요청한 프로세스는 입출력 장치가 입출력을 끝낼 때까지 기다려야 한다. 이렇게 **입출력 장치의 작업을 기다리는 상태를 대기 상태**라고 한다.
- 입출력 작업이 **완료되면 해당 프로세스는 다시 준비 상태로 CPU 할당을 기다린다**.

### 종료 상태(terminated)

- 프로세스가 종료된 상태이다.
- 프로세스가 **종료되면 운영체제는 PCB 와 프로세스가 사용한 메모리를 정리**한다.

## 프로세스 계층 구조

![Untitled](https://github.com/choidoorim/programing-books/assets/63203480/bac387dc-8e6b-4fe2-b07c-66c76a6e0be0)

- 프로세스 실행 도중에 시스템 호출을 통해 다른 프로세스를 생성할 수 있다. 새 프로세서를 생성한 프로세스를 부모 프로세스, 부모 프로세스에 의해 생성된 프로세스를 자식 프로세스라고 한다.
- 부모 프로세스와 자식 프로세스는 다른 프로세스이기 때문에 다른 PID 를 가진다. 일부 운영체제에서는 PCB 에 부모 프로세스의 PID 인 PPID 가 기록되기도 한다.
- 최초의 프로세스가 자식 프로세스를 생성하고, 자식 프로세스가 또 새로운 프로세스를 생성하는 형식으로 여러 프로세스가 동시에 실행된다. 도표로 그리면 트리 구조를 띄는데, 이를 프로세스 계층 구조라고 한다.
    - 사용자가 컴퓨터를 켜고 로그인 창을 통해 로그인 후 bash 셸로 Vim 이라는 문서 편집기 프로그램을 실행
        1. 최초 프로세스는 로그인을 담당하는 프로세스를 자식 프로세스로 생성한다.
        2. 로그인 프로세스는 bash 셸 프로세스를 자식 프로세스로 생성한다.
        3. bash 프로세스는 Vim 프로세스를 생성한다.
- 최초의 프로세스란 유닉스 운영체제에서는 init, 리눅스 운영체제에서는 systemd, macOS 에서는 launchd 라고 한다. 최초의 프로세스 PID 는 항상 1번이면, 모든 프로세스 최상단에 있는 부모 프로세스이다.

  <img width="201" alt="Untitled 1" src="https://github.com/choidoorim/programing-books/assets/63203480/08b89f91-3ec1-481d-925d-7a87ed63dd41">

## 프로세스 생성 기법

![Untitled 2](https://github.com/choidoorim/programing-books/assets/63203480/c5c8418f-1c63-489a-97b8-41fb812e12dc)

- fork 와 exec 는 시스템 호출이다.
- 부모 프로세스는 fork 를 통해 자신의 복제본을 자식 프로세스로 생성해내고, 만들어진 복사본(자식 프로세스)은 exec 를 통해 자신의 메모리 공간을 다른 프로그램으로 교체한다.
- fork 는 자기 자신 프로세스의 복사본을 만드는 시스템 호출이다. 자식 프로세스는 부모 프로세스의 복사본이기 때문에 자원(메모리 내용, 열린 파일의 목록 등)이 자식 프로세스에 상속된다. 복사된 자식 프로세스라도 PID 나 저장된 메모리 위치는 다르다. 그리고 fork 를 통해 예외나 오류 상황에서 안정성을 유지할 수 있다.
- exec 는 fork 를 통해 만들어진 복사본을 자신의 메모리 공간에 새로운 프로그램으로 덮어쓰는 시스템 호출이다. exec 를 호출하면 코드 영역과 데이터 영역의 내용이 실행할 프로그램의 내용으로 바뀌고, 나머지 영역은 초기화 된다.
- 부모 프로세스로부터 자식 프로세스가 복사되고, 자식 프로세스는 새로운 프로그램으로 옷을 갈아입고, 또 그 자식 프로세스로부터 자식 프로세스가 복사되는 등 여러 프로세스가 계층적으로 실행된다.
- 부모 프로세스가 자식 프로세스를 fork 하고 exec 를 호출하지 않는 경우도 있는데, 부모 프로세스와 자식 프로세스는 같은 코드를 병행하여 실행하는 프로세스가 된다.
- fork 를 통해 부모 프로세스에서 자식 프로세스를 생성하고 제어할 수 있고, exec 를 통해 자식 프로세스는 새로운 프로그램을 실행하여 원하는 작업을 수행한다.
