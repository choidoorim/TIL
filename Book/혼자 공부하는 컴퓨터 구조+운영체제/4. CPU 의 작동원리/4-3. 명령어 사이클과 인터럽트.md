## 명령어 사이클 
- 명령어 사이클은 인출, 실행, 간접, 인터럽트 사이클로 구성되어 있다.
- 프로그램은 수많은 명령어로 이루어져 있고, CPU 는 이 명령어들을 하나씩 실행한다. 프로그램 속 각각의 명령어들은 일정한 주기가 반복되며 실행되는데, 이 주기를 명령어 사이클(Instruction Cycle) 이라고 한다. 
- 명령어를 실행시키기 위해서는 CPU 에서 명령어를 메모리에서 가져와야 한다. 그리고 **명령어를 CPU 로 가지고 오는 단계를 인출 사이클(Fetch Cycle)** 이라고 한다. 
- CPU 로 명령어를 인출했다면 이제 명령어를 실행시켜야 한다. **CPU 로 가져온 명령어를 실행하는 단계를 실행 사이클(Execution Cycle)** 이라고 한다.
- 프로그램의 많은 명령어들은 일반적으로 인출과 실행 사이클을 반복하며 실행된다. 
- 메모리에서 명령어를 인출하여 CPU 로 가져왔다 하더라도 바로 실행 사이클에 돌입할 수 없다. **명령어를 실행하기 위해서 메모리 접근을 한 번 더** 해야하는데, 이 단계를 간접 사이클(Indirect Cycle) 이라고 한다.

![다운로드](https://user-images.githubusercontent.com/63203480/234309573-72b48f0d-c8e0-4eb8-b438-a74ab2fa2ece.png)


## 인터럽트(Interrupt)
- CPU 가 수행중인 작업은 방해를 받아 잠시 중단될 수 있다. **CPU 의 작업을 방해하는 신호**를 인터럽트라고 한다.
- 인터럽트의 종류는 동기 인터럽트와 비동기 인터럽트가 있다.

### 동기 인터럽트
- CPU 에 의해서 발생하는 인터럽트이다. 
- CPU 가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트가 동기 인터럽트이다. 이런 점에서 동기 인터럽트를 예외(Exception)이라고 하기도 한다.
- 예외의 종류로는 폴트, 트랩, 중단, 소프트웨어 인터럽트가 있다.
  - 폴트: 예외를 처리한 직후 **예외가 발생한 명령어부터 실행을 재개**하는 예외이다. 예를 들면, CPU 가 명령어를 실행하기 위해 필요한 데이터가 보조기억장치에 있다면, CPU 는 폴트를 발생시키고 보조기억장치로부터 필요한 데이터를 메모리로 가져와서 저장한다. 
  - 트랩: 예외를 처리한 직후 **예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외**이다. 예를 들면, 디버깅할 때 프로그램을 중단시키고 디버깅이 끝나면 프로그램은 다음 명령어부터 실행을 이어 나가면 된다.
  - 중단: CPU 가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생하는 예외이다.
  - 소프트웨어 인터럽트: 시스템 호출이 발생했을 때 나타낸다.

### 비동기 인터럽트/ 하드웨어 인터럽트 
- 입출력장치에 의해 발생하는 인터럽트이다. 
- 입출력 장치에 의한 비동기 인터럽트는 알림 역할을 한다. 
	- CPU 가 프린트와 같은 입출력장치에 입출력 작업을 부탁하면 작업을 끝낸 입출력 장치가 CPU 에 완료 알림(인터럽트)을 보낸다. 
	- 키보드, 마우스와 같은 입출력 장치가 어떠한 입력을 받아들였을 때 이를 처리하기 위해 CPU 에 알림을 보낸다.
- 일반적으로 비동기 인터럽트를 인터럽트라고 하기도 한다.
- CPU 는 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 알림기능을 하는 인터럽트를 사용한다. 
	- 입출력 장치는 CPU 에 비해 느리다. 그렇기 때문에 입출력 장치의 작업 결과를 바로 확인할 수 없다. 만약 하드웨어 인터럽트를 사용하지 않는다면 CPU 는 프린터가 언제 프린트를 끝낼지 모르기 때문에 주기적으로 프린터의 완료 여부를 체크해야 한다. 이 때문에 CPU 는 다른 일을 하지 못하기 때문에 CPU 사이클이 낭비된다. 
- 하드웨어 인터럽트를 이용하면 CPU 는 주기적으로 프린트 완료 여부를 확인할 필요가 없다. CPU 는 프린터로부터 프린트 완료 인터럽트를 받을 때까지 다른 작업을 처리할 수 있다. 즉, 하드웨어 인터럽트는 입출력 작업 중에도 CPU 로 하여금 효율적으로 명령어를 처리할 수 있다.

### 하드웨어 인터럽트 처리 순서
1. 입출력장치는 CPU 에 인터럽트 요청 신호를 보낸다.
2. CPU 는 실행 사이클이 끝나고 명령어를 인출하기 전에 항상 인터럽트 여부를 확인한다.
3. CPU 는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지를 확인한다. 
4. 인터럽트를 받아들일 수 있다면 **CPU 는 지금까지의 작업을 백업**한다.
5. CPU 는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행한다.
6. 인터럽트 서비스 루틴 실행이 끝나면 백업해 둔 작업을 복구하여 실행을 재개한다. 

- 인터럽트는 정상적인 CPU 의 흐름을 끊기 때문에 CPU 에게 지금 끼어들어도 되는지 물어봐야하는데, 이것을 인터럽트 요청 신호라고 한다.
- CPU 가 인터럽트 요청을 받아들이고 처리하기 위해서는 **플래그 레지스터의 인터럽트 플래그가 활성화**되어 있어야 한다.
  만약 인터럽트 플래그가 불가능으로 되어 있다면 CPU 는 인터럽트 요청을 무시한다.
- 인터럽트 플래그를 무시하고 인터럽트가 처리되는 경우도 있는데, 하드웨어 인터럽트 중 막을 수 없는 인터럽트 요청(ex. 정전, 하드웨어 고장)은 우선순위가 가장 높기에 가장 먼저 처리해야 하는 인터럽트이다. 
- CPU 가 인터럽트 요청을 받아들이기로 했다면, **CPU 는 인터럽트를 처리하기 위한 프로그램인 인터럽트 서비스 루틴(Interrupt Service Routine)을 실행**한다. 인터럽트 서비스 루틴은 인터럽트 핸들러라고도 부른다.
  인터럽트 서비스 루틴은 인터럽트가 발생했을 때, 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램이다.
- 각각의 입출력 장치마다 다른 인터럽트 서비스 루틴을 가지고 있다. 그리고 인터럽트 서비스 루틴들은 메모리에 저장되어 있다. 그리고 CPU 는 각각 다른 인터럽트 서비스 루틴을 구분할 수 있어야 하는데, **어떤 인터럽트 서비스 루틴인지 구별**하기 위해서 인터럽트 백터를 사용한다.
CPU 가 인터럽트 서비스 루틴을 실행하기 위해서는 인터럽트 서비스 루틴의 시작주소를 알아야 하는데, 이는 인터럽트 벡터를 통해 알 수 있다.
- 인터럽트가 발생한다면 이전에 CPU 가 수행중인 것들은 인터럽트 종료 후에 다시 수행해야 하기 때문에 프로그램을 다시 재개하기 위해 필요한 모든 내용(프로그램 카운터 값 등)들은 스택에 백업한다.
인터럽트가 발생한다고해서 이전에 프로그램 카운터 등의 값들은 덮어씌워지지 않는다는 것이다.
