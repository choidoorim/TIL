# lesson25. 일련번호와 확인 응답 번호의 구조

![Untitled](https://user-images.githubusercontent.com/63203480/236835088-378984d1-b9ce-427b-a4e3-e2fc583e1a01.jpeg)

## 1. 일련번호(Sequence Number)와 확인 응답 번호(Acknowledgment Number)란?

- 3-way handshake 가 끝나면 실제 **데이터를 보내거나 상대방이 받을 때는 TCP 헤더의 일련번호와 확인 응답 번호를 사용**한다.
- 데이터를 보낼 때는 분할해서 전송하는데 일련번호는 송신측에서 수신측에게 이 데이터가 분할된 데이터중에 몇 번째인지를 알려주는 역할을 한다.
- 확인 응답 번호는 수신 측이 몇 번째 데이터를 수신했는지 송신 측에 알려주는 역할을 한다. 예를 들면 10 번 데이터를 수신하면 11 번 데이터를 송신 측에 요청하는 것이다. 그리고 이것을 확인응답이라고 한다.
- 데이터 통신의 흐름은 아래와 같다. 일련번호 3001 은 처음 보내는 200 바이트 데이터의 첫 번째 바이트 번호이고, 확인 응답 번호는 다음에 보냈으면 하는 데이터의 첫 번째 바이트번호가 된다.

  ![Untitled](https://user-images.githubusercontent.com/63203480/236835974-09e9525f-da4e-45b3-a1f1-0a5b2dc1508e.jpeg)

    1. 컴퓨터1이 컴퓨터2에게 200 바이트의 데이터를 전송한다.
    2. 컴퓨터2는 200바이트의 데이터를 수신하고, **다음에 수신하고자하는 바이트 데이터 번호를 확인 응답 번호에 넣는다**. 다음에 수신하고자하는 데이터는 3001 + 200 인 3201 이므로 확인 응답 번호는 3201 이다.
        1. 만약에 수신측에서 200바이트가 아닌 500바이트를 받고 싶다면 3501이 될 것이다.
    3. 컴퓨터1이 컴퓨터2에게 3201번 바이트 데이트부터 200 바이트의 데이터를 전송한다.
    4. 컴퓨터2는 200바이트의 데이터를 수신하고, **다음에 수신하고자하는 바이트 데이터 번호를 확인 응답 번호에 넣는다**. 다음에 수신하고자하는 데이터는 3201 + 200 인 3401 이므로 확인 응답 번호는 3201 이다.

  1번부터 4번까지의 과정을 데이터 전송이 완료될 때까지 반복한다. 그리고 데이터는 유실되거나 손상될 수 있기 때문에 일련번호와 확인 응답 번호를 사용해서 손상되거나 유실되어 오류가 발생한다면 일정시간 대기 후에 재전송하게 되어 있다. 이것을 재전송 제어라고 한다.


## 2. 윈도우(Window) 크기란?

- 위 처럼 세그먼트(데이터)를 한 번 보낼 때마다 매번 확인 응답을 반환하고 기다리는 통신방식은 효율이 높지는 않다. 그렇기 때문에 매번 확인 응답을 기다리는 대신에 **세그먼트를 연속해서 보낸다음에 확인 응답을 반환**한다면 효율이 좋다.

  ![5](https://user-images.githubusercontent.com/63203480/236836062-a0662c98-3918-4f60-a48d-4d94c47e15a6.jpeg)

- 세그먼트를 연속해서 보낸다면 수신 측 버퍼(Buffer)에 받은 세그먼트들을 일시적으로 보관한다. 버퍼 덕분에 세그먼트를 연속해서 전송해도 수신측에서 대응이 가능하고 확인 응답의 효율도 높아진다.
    - 버퍼(Buffer): 데이터를 임시로 저장하여 데이터를 처리하는 동안 처리 속도를 향상시키거나 데이터 전송 과정에서 발생할 수 있는 지연을 최소화하는 데 사용하는 것으로 메모리(RAM)에 일시적으로 저장된다.
- 수신 측이 세그먼트를 너무 대량으로 받게되면 데이터가 보관되지 못하고 넘쳐버린다. 그리고 이것을 오버플로(overflow) 라고 한다. 오버플로가 발생하지 않도록 수신 측 버퍼의 한계를 알고 있어야 하는데 그것이 TCP 헤더의 window 값이다.
- 윈도우 크기는 **얼마나 많은 용량의 데이터를 저장할 수 있는지**를 나타내는 것이다. 그리고 윈도우 크기는 3-way handshake 를 할 때 판단한다. 이후에는 서로 윈도우 크기를 알고 있기 때문에 세그먼트를 오버플로우되지 않게 보낸다.
  ![6](https://user-images.githubusercontent.com/63203480/236836113-ae0f4790-baec-4748-8c0c-48dcb4dac264.png)
