# 2. 클로저와 메모리 관리

클로저는 객체지향과 함수형 모두를 아우르는 중요한 개념이다. 클로저는 메모리가 누수된다는 특징이 있지만 이는 클로저의 본질적인 특성이다. “메모리 누수”라는 표현은 개발자의 의도와 다르게 어떤 값의 참조 카운트가 0 이 되지 않아 GC 의 수거대상이 되지 못한 경우는 맞는 표현이다. 하지만 의도적으로 참조 카운트가 0 으로 되지 않게 설계한 경우에는 “누수”라고 볼 수 없다.

- 순환 참조는 왜 메모리 누수가 발생할까?

  순환참조란, 두 개 이상의 객체가 서로를 참조하는 상황이다. 이러한 상황에서 메모리 누수가 발생할 수 있습니다. 메모리 누수란, 더 이상 사용하지 않는 메모리 공간이 해제되지 않아서 시스템 자원이 낭비되는 현상이다. 순환참조에서 메모리 누수가 발생하는 이유는 다음과 같다..

    1. 참조 카운트 관리의 어려움
       순환참조 상황에서는 참조 카운트 관리가 어렵다. 참조 카운트란, 객체가 참조되는 횟수를 세는 것을 말한다. 객체가 더 이상 참조되지 않을 때 메모리를 해제하는데, 참조 카운트가 0이 되면 해당 객체를 해제할 수 있다. 그러나 순환참조 상황에서는 어떤 객체도 참조 카운트가 0이 되지 않으므로, 메모리를 해제할 수 없다.
    2. 가비지 컬렉터의 작동 방식
       일반적으로 가비지 컬렉터는 참조되지 않는 객체를 탐지하고, 해당 객체를 메모리에서 제거한다.. 그러나 순환참조 상황에서는 어떤 객체도 참조되지 않으므로, 가비지 컬렉터는 해당 객체를 메모리에서 제거하지 않는다..

  따라서 순환참조 상황에서는 메모리 누수가 발생할 수 있으며, 이를 해결하기 위해서는 참조 카운트를 관리하는 방법이나 가비지 컬렉터의 작동 방식을 개선하는 방법 등을 고려할 수 있다.


클로저는 필요에 의해서 의도적으로 함수의 지역 변수의 메모리를 소모하도록 하여 발생한다. 따라서 필요성이 사라지는 시점에는 더이상 메모리를 소모하지 않게 관리해주면 된다. 참조 카운트를 0 으로 만들면 GC 가 수거해갈 것이고, 이 때 소모됐던 메모리가 회수될 것이다. **참조카운트를 0 으로 만드는 방법은 식별자에 참조형 데이터가 아닌 기본형 데이터(`null, undefined`) 를 할당**해주면 된다.

```jsx
var outer = function () {
  var a = 1;
  var inner = function () {
    return ++a;
  }
  return inner;
};
var outer2 = outer();
console.log(outer2()); // 2
console.log(outer2()); // 3
outer = null; // outer 식별자의 inner 함수 참조를 끊음

(function () {
  var a = 0;
  var intervalId = null;
  var inner = function () {
    if (++a >= 10) {
      clearInterval(intervalId);
      inner = null; // inner 식별자의 함수 참조 끊음
    }
    console.log(a);
  };
  intervalId = setInterval(inner, 1000);
})();
```
