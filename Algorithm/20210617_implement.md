> **피지컬로 승부하기**  

-   구현이란 '머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정'이다.
-   구현은 별도의 유형이라 보기 어렵고, 이를 풀기 위해서는 프로그래밍 언어의 문법을 정확히 알고 있어야 하며 문제의 요구사항에 어긋나지 않는 답안 코드를 실수 없이 작성해야 한다.
-   프로그래밍 문법을 정확하게 숙지하지 못했거나, 라이브러리 사용 경험이 부족하면 구현 유형의 문제를 풀 때 불리하다.

> **예제 1 - 상하좌우**

> 여행가 A는 N × N 크기의 정사각형 공간 위에 서 있다. 이 공간은 1 × 1 크기의 정사각형으로 나누어져 있다. 가장 왼쪽 위 좌표는 (1, 1)이며, 가장 오른쪽 아래 좌표는 (N, N)에 해당한다. 여행가 A는 상, 하, 좌, 우 방향으로 이동할 수 있으며, 시작 좌표는 항상 (1, 1)이다. 하나의 줄에 띄어쓰기를 기준으로 하여 L, R, U, D 중 하나의 문자가 반복적으로 적혀있다. 각 문자의 의미는 다음과 같다.  
> L : 왼쪽으로 한 칸 이동, R : 오른쪽으로 한 칸 이동, U : 위로 한 칸 이동, D : 아래로 한 칸 이동  
> 여행가 A가 최종적으로 도착할 지점의 좌표를 출력하는 프로그램을 작성하시오.

> **Code**

```
def lrud():
    n = int(input())
    x, y = 1, 1
    plans = input().split()
    for plan in plans:
        print(x, y)
        if plan == 'L':
            nx = x
            ny = y - 1
        elif plan == 'R':
            nx = x
            ny = y + 1
        elif plan == 'U':
            nx = x - 1
            ny = y
        elif plan == 'D':
            nx = x + 1
            ny = y
        if nx < 1 or nx > n or ny < 1 or ny > n:
            continue
        x, y = nx, ny
    print(x, y)
    
lrud()
```

> **해설**

일련의 명령에 따라서 개체를 차례대로 이동시키는 시뮬레이션 유형이다. 연산 횟수는 이동 횟수에 비례하기 때문에 이동 횟수가 N번인 경우 시간 복잡도는 O(N)이다.

> **예제 2 - 시각**

> 정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하시오.

> **Code**

```
def time():
    n = int(input())
    count = 0
    for i in range(n+1):
        for j in range(60):
            for k in range(60):
                if '3' in str(i) + str(j) + str(k):
                    count += 1
    print(count)
    
time()
```

> **해설**

이 문제는 모든 시각의 경우를 하나씩 모두 세서 쉽게 풀 수 있는 문제이다. 왜냐하면 하루는 86,400초로 경우의 수가 86,400가지 밖에 존재하지 않기 때문이다. 전체 시, 분, 초에 대한 경우의 수는 24×60×60이며 3중 반복문을 이용해 계산할 수 있다.

-   완전 탐색 알고리즘 유형으로 가능한 경우의 수를 모두 검사해보는 탐색 방법이다.
-   전체 데이터의 개수가 100만 개 이하일 때 완전 탐색을 사용하면 적절하다.

> **실전 문제 - 왕실의 나이트**

> 행복 왕국의 왕실 정원은 체스판과 같은 8×8 좌표 평면이다. 왕실 정원의 특정한 한 칸에 나이트가 서 있다. 나이트는 말을 타고 있기 때문에 이동을 할 때는 L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없다. 나이트는 특정한 위치에서 다음과 같은 2가지의 경우로 이동할 수 있다.  
> 1\. 수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기  
> 2\. 수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기  
> 이처럼 8×8 좌표 평면상에서 나이트의 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램을 작성하시오. 행의 위치는 1부터 8, 열의 위치는 a부터 h로 표현한다.

> **Code**

```
def knight():
    location = input()
    row = int(location[1])
    column = ord(location[0]) - ord('a') + 1
    count = 0
    move_type = [(-1, 2), (1, 2), (-1, -2), (1, -2), (-2, 1), (-2, -1), (2, 1), (2, -1)]
    for move in move_type:
        next_row = row + move[0]
        next_column = column + move[1]
        if 0 < next_row <= 8 and 0 < next_column <= 8:
            count += 1
    print(count)
    
knight()
```

> **해설**

나이트의 이동 경로를 변수에 넣어 문제의 2가지 규칙(수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기, 수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기)에 따라 8가지의 값을 대입하면 된다.

> **실전 문제 - 게임 개발**

> 현민이는 게임 캐릭터가 맵 안에서 움직이는 시스템을 개발 중이다. 캐릭터가 있는 장소는 11크기의 정사각형으로 이뤄진 NM 크기의 직사강형으로, 각각의 칸은 육지 또는 바다이다. 캐릭터는 동서남북 중 한 곳을 바라본다. 맵의 각 칸은 (A, B)로 나타낼 수 있고, A는 북쪽으로부터 떨어진 칸의 개수, B는 서쪽으로부터 떨어진 칸의 개수이다. 캐릭터는 상하좌우로 움직일 수 있고, 바다로 되어 있는 공간에는 갈 수 없다. 캐릭터의 움직임을 설정하기 위해 정해 놓은 메뉴얼은 이러하다.  
> 1\. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향(반 시계 방향으로 90도 회전한 방향)부터 차례대로 갈 곳을 정한다  
> 2캐릭터의 바로 왼쪽 방향에 아직 가보지 않은 칸이 존재한다면, 왼쪽 방향으로 회전만 수행하고 1단계로 돌아간다  
> 3\. 만약 네 방향 모두 이미 가본 칸이거나 바다로 되어 있는 칸인 경우에는, 바라보는 방향을 유지한 채로 한 칸 뒤로 가고 1단계로 돌아간다. 단, 이때 뒤쪽 방향이 바다인 칸이라 뒤로 갈 수 없는 경우에는 움직임을 멈춘다  
> 메뉴얼에 따라 캐릭터를 이동시킨 뒤에, 캐릭터가 방문한 칸의 수를 출력하는 프로그램을 만드시오.

> **Code**

```
def game():
    n, m = map(int, input().split())
    move = [m * [0] for _ in range(n)]

    x, y, location = map(int, input().split())
    move[x][y] = 1

    dx = [-1, 0, 1, 0]
    dy = [0, 1, 0, -1]

    count = 1
    turn_count = 0

    maps = []
    for i in range(n):
        maps.append(list(map(int, input().split())))

    while True:
        location -= 1
        if location == -1:
            location = 3
        nx = x + dx[location]
        ny = y + dy[location]
        if move[nx][ny] == 0 and maps[nx][ny] == 0:
            move[nx][ny] = 1
            x = nx
            y = ny
            count += 1
            turn_count = 0
        else:
            turn_count += 1
        if turn_count == 4:
            nx = x - dx[location]
            ny = y - dy[location]
            if move[nx][ny] == 0:
                x = nx
                y = ny
            else:
                break
            turn_count = 0
    print(count)
 
 game()
```

> **해설**

전형적인 시뮬레이션 문제로 문제가 길고 문제를 바르게 이해하여 소스코드로 옮기는 과정이 간단하지 않다.

일반적으로 방향을 설정해서 이동하는 문제 유형에서는 dx, dy라는 별도의 리스트를 만들어 방향을 정하는 것이 효과적이다. 이처럼 코드를 작성하면 반복문을 이용하여 모든 방향을 차례대로 확인할 수 있다는 점에서 유용하다.

-   2차원 리스트를 선언할 때는 컴프리헨션을 이용하는 것이 효율적이다.