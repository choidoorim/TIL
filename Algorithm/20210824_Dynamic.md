한 번 계산한 문제는 다시 계산하지 않도록 하는 알고리즘입니다.

> **중복되는 연산을 줄이자**

컴퓨터는 연산 속도에 한계가 있고, 메모리 공간을 사용할 수 있는 데이터의 개수도 한정적입니다. 그래서 우리는 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘을 작성해야 합니다. **메모리 공간을 약간 더 사용하면서 연산 속도를 비약적으로 증가**시킬 수 있는 방법이 있는데 이것이 바로 **다이나믹 프로그래밍 기법 또는 동적 계획법**이라고 표현합니다.

다이나믹 프로그래밍으로 해결할 수 있는 대표적인 예시로는 피보나치 수열이 있습니다.

![다운로드](https://user-images.githubusercontent.com/63203480/130607011-8dc47aea-ad74-4829-88a1-9eb0970bae34.png)
사진 출처: [https://news.samsungdisplay.com/23402/](https://news.samsungdisplay.com/23402/)

피보나치 수열은 이전 두 항의 합을 현재의 항으로 설정하는 특징이 있는 수열입니다. 수학자들은 점화식을 사용해 수열의 항이 이어지는 형태를 간결하게 표현합니다. 점화식이란 인접한 항들 사이의 관계식을 의미합니다.

![1](https://user-images.githubusercontent.com/63203480/130607081-10792ad2-4450-4686-8b0d-7a00a56d85f7.png)
사진 출처: [https://www.opentutorials.org/module/5371/30552](https://www.opentutorials.org/module/5371/30552)

피보나치 수열의 점화식은 위와 같이 표현할 수 있습니다. 프로그래밍에서는 이러한 수열을 배열이나 리스트로 표현할 수 있습니다. 리스트나 배열 모두 '연속된 많은 데이터'를 처리한다는 점은 동일합니다. 수학적 점화식을 프로그래밍으로 표현하려면 재귀 함수를 사용하면 간단합니다.

```
def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)

print(fibo(4))
```

하지만 코드를 이런식으로 사용하게 되면 심각한 문제가 생길 수 있습니다. F(n) 함수에서 n 이 커질수록 수행 시간이 엄청나게 늘어납니다. 예를 들어 n = 30이면 약 10억 가량의 연산을 수행해야 합니다.

![1](https://user-images.githubusercontent.com/63203480/130607134-aa188496-7db2-4b35-8589-85667f0fcde0.png)
사진 출처: [https://www.opentutorials.org/module/5371/30552](https://www.opentutorials.org/module/5371/30552)

위 그림을 보면 동일한 수가 반복돼서 호출되는 것을 알 수 있습니다. 이러한 문제는 다이나믹 프로그래밍을 사용하면 효율적으로 해결할 수 있습니다. 하지만 항상 다이나믹 프로그래밍을 사용할 수는 없으며, 다음 조건을 만족해야 합니다.

1.  **큰 문제를 작은 문제로 나눌 수 있다.**
2.  **작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.**

피보나치 수열은 이러한 조건을 만족하는 대표적인 문제입니다. 해당 문제는 다이나믹프로그래밍을 구현하는 방법 중 하나인 메모이제이션 기법을 사용하여 해결할 수 있습니다.

* **메모제이션 기법**: 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법

> **피보나치 CODE**

```
d = [0] * 100


def fibo(x):
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]


print(fibo(4))
```

정리하자면 다이나믹 프로그래밍이란 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법입니다. 다이나믹 프로그래밍은 큰 문제에서 작게 나눈다는 분할 정복과 비슷하지만 **문제들이 서로 영향을 미치고 있다는 점**에서 차이점이 있습니다. 퀵 정렬은 한 번 연산을 하면 다시 처리하는 부분 문제는 존재하지 않지만, 다이나믹 프로그래밍은 이미 해결된 부분 문제에 대한 답을 저장해 놓고, 이 문제는 이미 해결이 됐던 것이니깐 다시 해결할 필요가 없다고 반환하는 것입니다.

![1](https://user-images.githubusercontent.com/63203480/130607197-38ac7f23-0c55-4d80-9074-e640c5aba899.png)
사진 출처: [https://yngie-c.github.io/data%20structure/2020/06/30/dynamic\_programming/](https://yngie-c.github.io/data%20structure/2020/06/30/dynamic_programming/)

재귀를 활용하면 컴퓨터 시스템에서 함수를 다시 호출했을 때 메모리 상에 적재되는 과정이 있기 때문에 오버헤드가 발생할 수 있습니다. 따라서 재귀 함수 대신 반복문을 통해 오버헤드를 줄일 수 있습니다.

> **피보나치 CODE(보텀업)**

```
d = [0] * 100
d[1] = 1
d[2] = 1
n = 4


for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]

print(d[n])
```

위와 같은 방법은 작은 문제부터 차근차근 답을 도출한다고 하여 **보텀업 방식**이라고 합니다. 반대로 재귀 함수를 이용한 풀이 방법은 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 **탑다운 방식**이라고 합니다. 다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식입니다.

앞서 수열은 배열이나 리스트로 표현할 수 있다고 했는데, 메모제이션은 때에 따라서 다른 자료형인 dictionary 를 이용할 수도 있습니다.

시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있기 때문에 코드를 작성할 때는 가능하다면 재귀 함수를 이용하는 탑다운 방식보다는 보텀업 방식으로 구현하는 것이 좋습니다.

---

> **실전 문제1 - 1로 만들기**

-   정수 X가 주어질 때 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지이다.

1.  X가 5로 나누어 떨어지면, 5로 나눈다.
2.  X가 2로 나누어 떨어지면, 2로 나눈다
3.  X가 3으로 나누어 떨어지면, 3으로 나눈다.
4.  X에서 1을 뺀다.

-   정수 X가 주어졌을 때, 연산 4개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.
-   예를 들어 정수가 26이면 다음과 같이 계산해서 3번의 연산이 최솟값이다.
    1.  26 - 1 = 25 (d)
    2.  25 / 5 = 5 (a)
    3.  5 / 5 = 1 (a)

> **실전 문제1 - CODE**

```
n = int(input())

d = [0] * 30001
for i in range(2, n + 1):
    # 현재에서 1을 빼주는 경우
    d[i] = d[i - 1] + 1
    # 현재에서 5, 3, 2로 나누어지는 경우
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)
    elif i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
    elif i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)

print(d[n])
```