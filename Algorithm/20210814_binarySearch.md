# 이진탐색
### 순차 탐색
- 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법
- 보통 정렬되지 않은 리스트에서 데이터를 찾아야 할 때 사용한다
- 리스트 내에 아무리 데이터가 많아도 시간만 충분하다면 항상 원하는 데이터를 찾을 수 있다는 장점이 있다
> CODE
```
def s_search(n, target, array):
    for i in range(len(array)):
        if array[i] == target:
            return i + 1

data = input().split()
n = int(data[0])
target = data[1]

array = input().split()

print(s_search(n, target, array))
```
- 순차 탐색은 데이터 정렬 여부와 상관없이 가장 앞에 있는 원소부터 하나씩 확인해야 한다는 점이 특징이다
### 이진탐색 : 반으로 쪼개면서 탐색하기
- 배열 내부의 데이터가 정렬되어 있어야만 사용할 수 있는 알고리즘입니다
  

- 데이터가 무작위일 때는 사용할 수 없지만, 이미 정렬되어 있다면 매우 빠르게 데이터를 찾을 수 있다는 특징이 있다
  

- 위치를 나타내는 변수 3개를 사용하는데 탐색하고자 하는 범위의 ```시작점, 끝점, 중간점```이다
  

- 찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교해서 원하는 데이터를 찾는 게 이진 탐색 과정이다   
절반씩 데이터를 줄어들도록 만든다는 점은 퀵 정렬과 공통점이 있다.
  

- 예를들면 데이터 개수가 32개 일 때, 1단계를 거치면 16개의 데이터가 남아있고, 2단계 8개, 3단계 4개...   
  즉, 단계마다 2로 나누는 것과 동일하므로연산 횟수는 ```log2N```에 비례한다 - 빅오 표기법(O(logN))

#### 이진 탐색 예시 - 이미 정렬된 10개의 데이터 중에서 값이 4인 원소 찾기
데이터 : 0 2 4 6 8 10 12 14 16 18
> step1
```
0(시작) 2 4 6 8(중간) 10 12 14 16 18(끝)   
시작점:0 중간점:4 끝점:9
```
시작점과 끝점을 확인한 다음 둘 사이에 중간점을 정한다. 중간점이 실수일 때는 소수점 이하를 버린다.
중간점 8과 찾으려는 값인 4를 비교한다. 중간점의 데이터 8이 더 크므로 중간점 이후의 값은 확인할 필요가 없다.  
끝점을 중간점의 이전으로 옮긴다.
> step2
```
0(시작) 2(중간점) 4 6(끝점) -- 8 10 12 14 16 18   
시작점:0 중간점:1 끝점:3
```
중간점에 위치한 데이터 2는 찾으려는 데이터 4보다 작으므로 이번에는 값이 2 이하인 데이터는 더 이상 확인할 필요가 없다.   
따라서 시작점을 2로 변경한다.
> step3
```
0 2 4(시작, 중간) 6 8(중간) 10 12 14 16 18(끝)   
시작점:2 중간점:2 끝점:3
```
중간점에 위치한 데이터가 일치하므로 탐색 종료한다.

- 이진 탐색을 구현하는 방법
    1. 재귀 함수
    2. 단순하게 반복문 이용
    
#### 1. 이진 탐색 - 재귀 함수
> CODE
```
def b_search_recursive(array, target, start, end):
    if start > end:
        return None
    mid = (start + end) // 2
    if array[mid] == target:
        return mid
    elif array[mid] > target:
        return b_search_recursive(array, target, start, mid - 1)
    else:
        return b_search_recursive(array, target, mid + 1, end)


n, target = map(int, input().split())
array = list(map(int, input().split()))

result = b_search_recursive(array, target, 0, n - 1)
if result is None:
    print('원소가 없다.')
else:
    print(result + 1)
```
#### 2. 이진 탐색 - 반복문
> CODE
```
def b_search(array, target, start, end):
    while start <= end:
        mid = (start + end) // 2
        if array[mid] == target:
            return mid
        elif array[mid] > target:
            end = mid - 1
        else:
            start = mid + 1
    return None

n, target = map(int, input().split())
array = list(map(int, input().split()))

result = b_search(array, target, 0, n - 1)
if result is None:
    print('원소가 없다.')
else:
    print(result + 1)
```
#### 트리 자료구조
- 동작하는 프로그램에서 데이터를 정렬해두는 경우가 많으므로 이진 탐색을 효과적으로 사용할 수 있다.
- DB 는 내부적으로 대용량 데이터 처리에 적합한 트리 자료구조를 이용하여 항상 데이터가 정렬되어 있다.   
따라서 DB 에서 이진 탐색과 유사한 방법을 이용해 탐색을 항상 빠르게 수행하도록 설계되어 있어 탐색 속도가 빠른 것이다.
  
- 노드와 노드의 연결로 표현하며 노드는 정보의 단위로서 어떠한 정보를 가지고 있는 개체로 이해할 수 있다.
- 트리 자료구조는 그래프 자료구조의 일종으로 데이터베이스 시스템이나 파일 시스템 같은 곳에서 많은 양의 데이터를 관리하기 위한 목적으로 사용한다.
> 트리자료구조의 특징
1. 부모 노드와 자식 노드의 관계로 표현된다.
2. 최상단 노드를 루트 노드라고 한다.
3. 최하단 노드를 단말 노드라고 한다.
4. 일부를 떼어내도 트리 구조이며, 이를 서브 트리라고 한다.
5. 계층적이고 정렬된 데이터를 다루기에 적합하다.

#### 이진 탐색 트리
- 트리 자료구조 중에서 가장 간단한 형태로 이진 탐색이 동작할 수 있도록 고안된, 효율적인 탐색이 가능한 자료구조이다.


- 이진 탐색 트리의 특징
    1. 부모 노드보다 왼쪽 자식 노드가 작다.
    2. 부모 노드보다 오른쪽 자식 노드가 크다.
    - 왼쪽 자식노드 <  부모 노드 < 오른쪽 자식 노드

예제) 이진 탐색 트리에서 14 값을 찾을 때  

![2321CB4951A467AC0B](https://user-images.githubusercontent.com/63203480/129387759-17f5a5ec-c0df-4b99-a26c-b580edce2824.png)

[사진 출처](https://blog.hexabrain.net/248)
> step 1
- 이진 탐색은 루트 노드부터 방문한다. 루트 노드는 10이고 찾는 원소 값은 14이다.
- 공식에 따라 부모 노드의 왼쪽 자식 노드는 10 이하이므로 오른쪽 노드만 확인하면 된다.
> step 2
- 오른쪽 자식 노드인 17이 이번에는 부모 노드이다.
- '17'은 찾는 원소 값인 '14'보다 크다. 따라서 공식에 따라 부모 노드 17의 왼쪽 노드를 확인한다.
> step 3
- 현재 방문한 노드의 값인 '14'와 찾는 원소 값이 동일하므로 탐색을 마친다.

#### 빠르게 입력 받기
이진 탐색 문제는 대체로 입력이 많거나, 탐색 범위가 매우 넓은 편이다.   
따라서 ```input()```함수를 사용하면 동작 속도가 느려서 시간초과로 오답 가능성이 생길 수 있다.   
이처럼 입력 데이터가 많은 문제는 ```sys``` 라이브러리의 ```readline()```함수를 이용하면 시간 초과를 피할 수 있다.
```
import sys
input_data = sys.stdin.readline().rstrip()

print(input_data)
```
sys 라이브러리를 사용할 때는 한 줄 입력받고 나서 ```rstrip()```함수를 꼭 호출해야 한다.   
```readline()```으로 입력하면 입력 후 엔터가 줄 바꿈 기호로 입력되기 때문이다.